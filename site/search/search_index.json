{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mad-Pascal Mad-Pascal (MP) is a 32-bit Turbo Pascal compiler for Atari XE/XL . By design, it is compatible with the Free Pascal Compilator (FPC) (the -MDelphi switch should be active), which means the possibility of obtaining executable code for XE/XL , PC and every other platform for which FPC exists. MP is not a port of FPC ; it has been written based on of SUB-Pascal (2009), XD-Pascal (2010), the author of which is Vasiliy Tereshkov . Sources are on GitHub with release for Windows operating system.","title":"Mad-Pascal"},{"location":"#mad-pascal","text":"Mad-Pascal (MP) is a 32-bit Turbo Pascal compiler for Atari XE/XL . By design, it is compatible with the Free Pascal Compilator (FPC) (the -MDelphi switch should be active), which means the possibility of obtaining executable code for XE/XL , PC and every other platform for which FPC exists. MP is not a port of FPC ; it has been written based on of SUB-Pascal (2009), XD-Pascal (2010), the author of which is Vasiliy Tereshkov . Sources are on GitHub with release for Windows operating system.","title":"Mad-Pascal"},{"location":"asm/","text":"ASM Assembler blocks are not verified for syntax by the compiler, this is done only by Mad Assembler . WARNING: It is required to maintain the state of the X CPU6502 register, which is used to operate the MP software stack. The compiler allows two syntaxes for the ASM block, with { } brackets as for a comment and the standard one without brackets. ASM lda #10 sta 712 END; ASM { lda #10 sta 712 }; procedure name; assembler; asm lda #10 sta 712 end; procedure name; assembler; asm { lda #10 sta 712 }; end;","title":"Assembly instructions"},{"location":"asm/#_1","text":"","title":""},{"location":"asm/#asm","text":"Assembler blocks are not verified for syntax by the compiler, this is done only by Mad Assembler . WARNING: It is required to maintain the state of the X CPU6502 register, which is used to operate the MP software stack. The compiler allows two syntaxes for the ASM block, with { } brackets as for a comment and the standard one without brackets. ASM lda #10 sta 712 END; ASM { lda #10 sta 712 }; procedure name; assembler; asm lda #10 sta 712 end; procedure name; assembler; asm { lda #10 sta 712 }; end;","title":"ASM"},{"location":"constants/","text":"Ordinary constants The character = is used for the CONST constant declarations. The use of operators: + - * / not and or div mod ord chr sizeof pi const e = 2.7182818; { Real type constant } f : single = 3.14; { Single type constant } a = 2; { Ordinal BYTE type constant } c = '4'; { Character type constant } s = 'atari'; { String type constant } sc = chr(32); ls = SizeOf(cardinal); x: word = 5; { forcing the type of constant }","title":"Constants"},{"location":"constants/#_1","text":"","title":""},{"location":"constants/#ordinary-constants","text":"The character = is used for the CONST constant declarations. The use of operators: + - * / not and or div mod ord chr sizeof pi const e = 2.7182818; { Real type constant } f : single = 3.14; { Single type constant } a = 2; { Ordinal BYTE type constant } c = '4'; { Character type constant } s = 'atari'; { String type constant } sc = chr(32); ls = SizeOf(cardinal); x: word = 5; { forcing the type of constant }","title":"Ordinary constants"},{"location":"essential-libraries/","text":"W katalogu LIB Mad-Pascala znajduj\u0105 si\u0119 potrzebne do kompilacji podstawowe modu\u0142y UNIT , takie jak SYSTEM CRT GRAPH SYSUTILS MATH DOS . W programie wybierane s\u0105 przez instrukcj\u0119 USES , np.: uses crt, sysutils; Modu\u0142 SYSTEM jest domy\u015blnie dopisywany do listy USES i kompilowany jako pierwszy. SYSTEM Constants M_PI_2 = 6.283285; // pi * 2 D_PI_2 = 1.570796; // pi / 2 D_PI_180 = 0.017453; // pi / 180 mGTIA = 0; mVBXE = $80; WINDOW = $10; NARROW = $20; VBXE_XDLADR = $0000; // XDLIST VBXE_MAPADR = $1000; // COLOR MAP ADDRESS VBXE_BCBADR = $0100; // BLITTER LIST ADDRESS VBXE_OVRADR = $5000; // OVERLAY ADDRESS VBXE_WINDOW = $B000; // 4K WINDOW $B000..$BFFF iDLI = 0; iVBL = 1; CH_DELCHR = $FE; CH_ENTER = $9B; CH_ESC = $1B; CH_CURS_UP = 28; CH_CURS_DOWN = 29; CH_CURS_LEFT = 30; CH_CURS_RIGHT = 31; CH_TAB = $7F; CH_EOL = $9B; CH_CLR = $7D; CH_BEL = $FD; CH_DEL = $7E; CH_DELLINE = $9C; CH_INSLINE = $9D; COLOR_BLACK = $00; COLOR_WHITE = $0e; COLOR_RED = $32; COLOR_CYAN = $96; COLOR_VIOLET = $68; COLOR_GREEN = $c4; COLOR_BLUE = $74; COLOR_YELLOW = $ee; COLOR_ORANGE = $4a; COLOR_BROWN = $e4; COLOR_LIGHTRED = $3c; COLOR_GRAY1 = $04; COLOR_GRAY2 = $06; COLOR_GRAY3 = $0a; COLOR_LIGHTGREEN = $cc; COLOR_LIGHTBLUE = $7c; Types TPoint TPoint = record x,y: SmallInt end; Definicja wsp\u00f3\u0142rz\u0119dnych (x,y). TRect TRect = record left, top, right, bottom: smallint end; Definicja po\u0142o\u017cenia i rozmiaru czworok\u0105ta o parametrach (left, top) - lewy g\u00f3rny naro\u017cnik, (right, bottom) - prawy dolny naro\u017cnik. TString TString = string[32]; Definicja kr\u00f3tkiego ci\u0105gu znakowego wykorzystywanego do przekazywania nazw plik\u00f3w itp. Variables IOResult IOResult: byte; Zmienna przechowuje ostatni b\u0142\u0105d operacji I/O . Kody b\u0142\u0119d\u00f3w I/O . ScreenWidth ScreenWidth: word = 40 Zmienna przechowuj\u0105ca aktualn\u0105 szeroko\u015b\u0107 ekranu. Domy\u015blnie jest to warto\u015b\u0107 40 dla ekranu edytora. ScreenHeight: word = 24; ScreenHeight Zmienna przechowuj\u0105\u0107a aktualn\u0105 wysoko\u015b\u0107 ekranu. Domy\u015blnie jest to warto\u015b\u0107 24 dla ekranu edytora. Procedures and functions Abs ArcTan Assign BinStr Concat Blockread Blockwrite Chr Cos Close Dec DeleteFile DPeek DPoke Eof Exit Exp FilePos FileSize FillChar Frac GetIntVec Halt Hi HexStr Inc Ln Lo LowerCase Move OctStr Odd Ord ParamCount ParamStr Pause Peek Point PointsEqual Poke Pred Random ReadConfig ReadSecto Rect RenameFile Reset Rewrite Round Seek SetLength SetIntVec Sin Succ Space SizeOf Str StringOfChar Sqr Sqrt Trunc UpCase Val WriteSector Abs function Abs(x: real): real; function Abs(x: integer): integer; Funkcja obliczaj\u0105ca warto\u015b\u0107 bezwzgl\u0119dn\u0105 podanej liczby (ang. Absolute value ). Warto\u015b\u0107 bezwzgl\u0119dna liczby nieujemnej to ta sama liczba, a liczby ujemnej - liczba do niej przeciwna. Funkcja w przypadku podania jej argumentu ca\u0142kowitego zwraca wynik r\u00f3wnie\u017c typu ca\u0142kowitego. ArcTan function ArcTan(x: real): real; Funkcja (arcus tangens) zwraca warto\u015b\u0107 k\u0105ta, kt\u00f3rego tangens wynosi x . Assign procedure Assign(var F:File; FileName:string) Procedura przypisuje zmiennej plikowej F plik o nazwie FileName . Aby m\u00f3c odwo\u0142ywa\u0107 si\u0119 do jakiego\u015b pliku, zawsze nale\u017cy najpierw u\u017cy\u0107 procedury Assign . Przy dalszych operacjach pliki s\u0105 identyfikowane przy pomocy zmiennej plikowej, a nie nazwy. BinStr function BinStr(Value: cardinal; Digits: byte): TString; Funkcja zwraca ci\u0105g znakowy z reprezentacj\u0105 binarn\u0105 warto\u015bci Value . Digits okre\u015bla d\u0142ugo\u015b\u0107 ci\u0105gu, kt\u00f3ry maksymalnie mo\u017ce liczy\u0107 32 znaki. Concat function Concat(a,b: string): string; assembler function Concat(a: string; b: char): string; assembler; function Concat(a: char; b: string): string; assembler; function Concat(a,b: char): string; Funkcja \u0142\u0105czy dwa ci\u0105gi tekstowe w nowy ci\u0105g znakowy. Blockread procedure BlockRead(var f: file; var Buf; Count: word; var Result: word); Procedura wczytuje z pliku plik do zmiennej Buf nie wi\u0119cej ni\u017c Count bajt\u00f3w i umieszcza w zmiennej Result ilo\u015b\u0107 rzeczywi\u015bcie przeczytanych bajt\u00f3w (kt\u00f3ra mo\u017ce by\u0107 mniejsza od oczekiwanej np. ze wzgl\u0119du na rzeczywist\u0105 d\u0142ugo\u015b\u0107 pliku). Blockwrite procedure BlockWrite(var f: file; var Buf; Count: word; var Result: word); Procedura zapisuje do pliku ze zmiennej Buf nie wi\u0119cej ni\u017c Count bajt\u00f3w. Chr Chr(65); // Zwraca znak A Chr(90); // Zwraca znak Z Chr(32); // Zwraca znak spacji Writeln(#65); // Znak A Writeln(#65#32#65); // Napisze 'A Z' Funkcja zwraca znak Char o odpowiadaj\u0105cym kodzie ATASCII podanym w parametrze. Zamiennie z funkcj\u0105 Chr , chc\u0105c uzyska\u0107 odpowiedni znak mo\u017cemy u\u017cy\u0107 jego kodu ATASCII poprzedzaj\u0105c go # . Cos function Cos(x: real): real; Cosinus k\u0105ta, x w radianach. Close procedure Close(var f: file); Procedura s\u0142u\u017c\u0105ca do zamykania otwartego pliku dowolnego typu. Ka\u017cdy plik otwarty przy pomocy Reset lub Rewrite powinno si\u0119 zamkn\u0105\u0107 przy pomocy Close . Dec procedure Dec(var X [, N: int]); Procedura zmniejsza warto\u015b\u0107 parametru X o 1 lub warto\u015b\u0107 parametru N . Warto\u015b\u0107 parametru X mo\u017ce by\u0107 typu CHAR BYTE WORD CARDINAL . Procedura DEC generuje optymalny kod, jest zalecana do u\u017cywania w p\u0119tlach, zamiast operatora odejmowania - . dec(tmp); dec(tmp[2]); DeleteFile function DeleteFile(FileName: string): Boolean; Funkcja pozwala skasowa\u0107 plik z dysku o nazwie FileName , zwraca TRUE kiedy operacja powiod\u0142a si\u0119, FALSE w przypadku wyst\u0105pienia b\u0142\u0119du (najcz\u0119\u015bciej z powodu zabezpieczenia przed zapisem lub b\u0142\u0119dnej nazwy pliku). DPeek function DPeek(a: word): word; Funkcja zwraca s\u0142owo spod adresu a . DPoke procedure DPoke(a: word; value: word); Procedura zapisuje s\u0142owo value pod adresem a . Eof function Eof(var f: file): Boolean; Funkcja zwraca warto\u015b\u0107 logiczn\u0105 TRUE je\u015bli osi\u0105gni\u0119ty zosta\u0142 koniec pliku. Exit Wywo\u0142anie procedury Exit powoduje natychmiastowe opuszczenie bloku programu, w kt\u00f3rym to wywo\u0142anie nast\u0105pi\u0142o. Mo\u017cna jej u\u017cy\u0107 do opuszczenia p\u0119tli, wyj\u015bcia z procedury/funkcji lub programu g\u0142\u00f3wnego. Exp function Exp(x: real): real; Funkcja podnosz\u0105ca liczb\u0119 e (=2.71) do pot\u0119gi podanej przez argument x . FilePos function FilePos(var f: file): cardinal; Funkcja zwraca aktualn\u0105 pozycj\u0119 pliku. Plik nie mo\u017ce by\u0107 tekstowy i musi by\u0107 otwarty (np. poleceniem Reset ). Bity 0..15 zwr\u00f3conej warto\u015bci to numer sektora dysku, bity 16..23 pozycja w sektorze [0..255] . Jest to odpowiednik instrukcji NOTE . FileSize function FileSize(var f: file): cardinal; Funkcja zwraca d\u0142ugo\u015b\u0107 pliku w bajtach ( Sparta DOS X ). Plik nie mo\u017ce by\u0107 tekstowy i musi by\u0107 otwarty (np. poleceniem Reset ). FillChar procedure FillChar(x: pointer; count: word; value: char); Procedura wype\u0142nia bufor okre\u015blony w parametrze X identycznymi znakami lub bajtami. Parametr value musi okre\u015bla\u0107 dane, natomiast count - ilo\u015b\u0107 danych jakie zostan\u0105 przypisane do bufora. var Buffer : array[0..100] of Char; begin FillChar(Buffer, SizeOf(Buffer), 'A'); end. Frac function Frac(x: real): real; Zwraca cz\u0119\u015b\u0107 u\u0142amkow\u0105 liczby x w postaci rzeczywistej. GetIntVec procedure GetIntVec(intno: byte; var vector: pointer); Procedura odczytuje adres wektora przerwa\u0144 wg. kodu INTNO . Obecnie dopuszczalnymi kodami s\u0105: iDLI przerwanie DLI, iVBL przerwanie VBL. Halt procedure halt; Wywo\u0142anie powoduje natychmiastowe wyj\u015bcie z programu. Mo\u017cna (opcjonalnie) poda\u0107 kod b\u0142\u0119du, w przypadku MP jest on ignorowany. Hi function Hi(x): byte Funkcja zwracaj\u0105ca starszy bajt parametru x . HexStr function HexStr(Value: cardinal; Digits: byte): TString; Funkcja zwraca ci\u0105g znakowy z reprezentacj\u0105 heksadecymaln\u0105 warto\u015bci Value . Digits okre\u015bla d\u0142ugo\u015b\u0107 ci\u0105gu, kt\u00f3ry maksymalnie mo\u017ce liczy\u0107 32 znaki. Inc Inc procedure Inc(var X [, N: int]); Procedura zwi\u0119ksza warto\u015b\u0107 parametru X o 1 lub warto\u015b\u0107 parametru N . Warto\u015b\u0107 parametru X mo\u017ce by\u0107 typu CHAR BYTE WORD CARDINAL . Procedura INC generuje optymalny kod, jest zalecana do u\u017cywania w p\u0119tlach, zamiast operatora dodawania + . inc(tmp); inc(tmp[2]); Int function Int(x: real): real; Funkcja zwraca cz\u0119\u015b\u0107 ca\u0142kowit\u0105 argumentu b\u0119d\u0105cego liczb\u0105 rzeczywist\u0105. Ln function Ln(x: real): real; Funkcja licz\u0105ca logarytm naturalny (o podstawie e) z podanej liczby. Argument funkcji musi by\u0107 dodatni ! Lo function Lo(x): byte; Funkcja zwracaj\u0105ca m\u0142odszy bajt parametru X . LowerCase function LowerCase(a: char): char; Funkcja zmieniaj\u0105ca znaki 'A'..'Z' na odpowiednie ma\u0142e znaki 'a'..'z'. Move procedure Move(source, dest: pointer; count: word); Procedura s\u0142u\u017cy do kopiowania danych ze \u017ar\u00f3d\u0142a, parametr Source , do bufora oznaczonego jako przeznaczenie, parametr Dest . Ilo\u015b\u0107 kopiowanych danych okre\u015bla parametr Count . OctStr function OctStr(Value: cardinal; Digits: byte): TString; Funkcja zwraca ci\u0105g znakowy z reprezentacj\u0105 \u00f3semkow\u0105 warto\u015bci Value . Digits okre\u015bla d\u0142ugo\u015b\u0107 ci\u0105gu, kt\u00f3ry maksymalnie mo\u017ce liczy\u0107 32 znaki. Odd function Odd(x: cardinal): Boolean; function Odd(x: integer): Boolean; Funkcja zwraca warto\u015b\u0107 True je\u017celi liczba okre\u015blona w parametrze X jest nieparzysta, False je\u017celi jest parzysta. Ord function Ord(X); Funkcja ta dzia\u0142a odwrotnie do Chr . Z podanego znaku jako parametr zwraca nam jego kod w ATASCII . Ord('A'); // Zwraca 65 Ord('Z'); // Zwraca 90 Ord(' '); // Zwraca 32 ParamCount function ParamCount: byte; Funkcja zwraca ilo\u015b\u0107 dost\u0119pnych argument\u00f3w ( Sparta Dos X , BWDos ), tzn. maksymalny indeks dla procedury ParamStr . ParamCount okre\u015bla ilo\u015b\u0107 parametr\u00f3w przekazanych do programu z linii polece\u0144. ParamStr function ParamStr(Index: byte): TString; Funkcja zwraca parametry programu ( Sparta Dos X , BWDos ). Index to numer parametru, czyli ci\u0105gu znak\u00f3w oddzielonego spacj\u0105. Je\u017celi uruchomimy program TEST.EXE w taki spos\u00f3b: TEST.EXE parametr1 parametr2 parametr3 To aby uzyska\u0107 parametr3 nale\u017cy poda\u0107 Index=3 , za\u015b aby uzyska\u0107 parametr1 nale\u017cy Index=1 . Index=0 to specjalny argument, wtedy funkcja zwraca nap\u0119d z kt\u00f3rego zosta\u0142 uruchomiony programu, np. D1: . Pause procedure Pause; procedure Pause(n: word); Procedura zatrzymuje dzia\u0142anie programu na N * 1.50 sek. Peek function Peek(a: word): byte; Funkcja zwraca bajt spod adresu a . Point function Point(AX, AY: smallint): TPoint; Funkcja na podstawie parametr\u00f3w AX oraz AY tworzony jest rekord typu TPoint . PointsEqual function PointsEqual(const P1, P2: TPoint): Boolean; Funkcja sprawdza czy warto\u015bci wsp\u00f3\u0142rz\u0119dnych okre\u015blone w parametrach P1 oraz P2 s\u0105 sobie r\u00f3wne. W takim wypadku funkcja zwraca warto\u015b\u0107 True . Poke procedure Poke(a: word; value: byte); Procedura zapisuje bajt value pod adresem a . Pred function Pred(X: TOrdinal): TOrdinal; Poprzednik elementu X . Random function Random: Real; assembler; Funkcja zwraca losow\u0105 warto\u015b\u0107 z przedzia\u0142u <0 .. 1> . function Random(range: byte): byte; assembler; Funkcja zwraca losow\u0105 warto\u015b\u0107 z przedzia\u0142u <0 .. range-1> , w przypadku Range=0 zwraca warto\u015b\u0107 losow\u0105 z przedzia\u0142u <0 .. 255 > . function Random(range: smallint): smallint; Funkcja zwraca losow\u0105 warto\u015b\u0107 z przedzia\u0142u <0 .. range-1> . ReadConfig function ReadConfig(devnum: byte): cardinal; Odczyt statusu stacji devnum . Wynikiem s\u0105 cztery bajty DVSTAT ($02EA..$02ED) . Byte 0 ($02ea): Bit 0:Indicates the last command frame had an error. Bit 1:Checksum, indicates that there was a checksum error in the last command or data frame Bit 2:Indicates that the last operation by the drive was in error. Bit 3:Indicates a write protected diskette. 1=Write protect Bit 4:Indicates the drive motor is on. 1=motor on Bit 5:A one indicates MFM format (double density) Bit 6:Not used Bit 7:Indicates Density and a Half if 1 Byte 1 ($02eb): Bit 0:FDC Busy should always be a 1 Bit 1:FDC Data Request should always be 1 Bit 2:FDC Lost data should always be 1 Bit 3:FDC CRC error, a 0 indicates the last sector read had a CRC error Bit 4:FDC Record not found, a 0 indicates last sector not found Bit 5:FDC record type, a 0 indicates deleted data mark Bit 6:FDC write protect, indicates write protected disk Bit 7:FDC door is open, 0 indicates door is open Byte 2 ($2ec): Timeout value for doing a format. Byte 3 ($2ed): not used, should be zero ReadSector procedure ReadSector(devnum: byte; sector: word; var buf); Procedura odczytuje sektora sector dyskietki w stacji dysk\u00f3w devnum i zapisanie go w buforze buf . Rect function Rect(ALeft, ATop, ARight, ABottom: smallint): TRect; Funckja na podstawie parametr\u00f3w tworzy rekord typu TRect . RenameFile function RenameFile(OldName, NewName: string): Boolean; Funkcja pozwala zmieni\u0107 nazw\u0119 pliku OldName na now\u0105 nazw\u0119 NewName , zwraca TRUE kiedy operacja powiod\u0142a si\u0119, FALSE w przypadku wyst\u0105pienia b\u0142\u0119du (najcz\u0119\u015bciej z powodu zabezpieczenia przed zapisem lub b\u0142\u0119dnej nazwy pliku). RenameFile('D:OLDNAME.TMP', 'NEWNAME.TMP'); Reset procedure Reset(var f: file; l: Word); Procedura otwiera istniej\u0105cy plik z nazw\u0105 przekazan\u0105 do F poleceniem Assign . Opcjonalnie mo\u017cemy poda\u0107 rozmiar rekordu w bajtach L , domy\u015blnie jest to warto\u015b\u0107 128. Rewrite procedure Rewrite(var f: file; l: Word); Procedura tworzy i otwiera nowy plik. f jest nazw\u0105 przekazan\u0105 za pomoc\u0105 polecenia Assign . Opcjonalnie mo\u017cemy poda\u0107 rozmiar rekordu w bajtach l , domy\u015blnie jest to warto\u015b\u0107 128. Round function Round(x: real): integer; Funkcja dokonuje zaokr\u0105glenia podanej liczby rzeczywistej do najbli\u017cszej liczby ca\u0142kowitej. Seek procedure Seek(var f: file; N: cardinal); Procedura ustawia pozycj\u0119 w pliku na N . N powinno by\u0107 warto\u015bci\u0105 zwr\u00f3con\u0105 przez FilePos . Jest to odpowiednik instrukcji POINT . SetLength procedure SetLength(var S: string; Len: byte); Procedura ustawia d\u0142ugo\u015b\u0107 ci\u0105gu S na LEN . SetIntVec procedure SetIntVec(intno: Byte; vector: pointer); Procedura ustawia adres wektora przerwa\u0144 wg. kodu INTNO . Obecnie dopuszczalnymi kodami s\u0105: iDLI przerwanie DLI, iVBL przerwanie VBL. Sin function Sin(x: real): real; Sinus k\u0105ta. x w radianach. Succ function Succ(X: TOrdinal): TOrdinal; Nast\u0119pnik elementu X . Space function Space(Len: Byte): ^char; Funkcja generuje nowy ci\u0105g znakowy o d\u0142ugo\u015bci Len wype\u0142niony znakami spacji. SizeOf function SizeOf(X: AnyType): byte; Funkcja zwraca rozmiar podanej zmiennej (lub typu) w bajtach. Str procedure Str(var X: TNumericType; var S: string); Procedura zamienia liczb\u0119 X na \u0142a\u0144cuch znak\u00f3w S . StringOfChar procedure StringOfChar(ch: Char; len: byte): ^char; Funkcja generuje nowy ci\u0105g znakowy o d\u0142ugo\u015bci len wype\u0142niony znakami ch . Sqr function Sqr(x: real): real; function Sqr(x: integer): integer; Funkcja obliczaj\u0105ca kwadrat podanej liczby (ang. Square ). Sqrt function Sqrt(x: real): real; function Sqrt(x: single): single; function Sqrt(x: integer): single; Funkcja obliczaj\u0105ca pierwiastek kwadratowy podanej liczby (ang. Square root ). Trunc function Trunc(x: real): integer; Funkcja zwraca cz\u0119\u015b\u0107 ca\u0142kowit\u0105 liczby rzeczywistej w postaci liczby ca\u0142kowitej. UpCase function UpCase(a: char): char; Funkcja zmieniaj\u0105ca znaki 'a'..'z' na odpowiednie du\u017ce znaki 'A'..'Z' . Val procedure Val(const S: string; var V; var Code: Byte); Procedura przekszta\u0142ca ci\u0105g znak\u00f3w S na liczb\u0119 V . Code przyjmie warto\u015b\u0107 0 je\u015bli nie by\u0142o b\u0142\u0119dnych znak\u00f3w, w przeciwnym wypadku przyjmie numer znaku kt\u00f3ry spowodowa\u0142 b\u0142\u0105d konwersji. WriteSector procedure WriteSector(devnum: byte; sector: word; var buf); Procedura zapisuje sektora sector dyskietki w stacji devnum na podstawie bufora buf . CRT Constants CN_START_SELECT_OPTION = 0; CN_SELECT_OPTION = 1; CN_START_OPTION = 2; CN_OPTION = 3; CN_START_SELECT = 4; CN_SELECT = 5; CN_START = 6; CN_NONE = 7; Variables Consol Consol: byte absolute $d01f Zmienna zwraca kod naci\u015bni\u0119tego klawisza/klawiszy konsoli. TextAttr TextAttr: byte = 0 Zmienna przechowuje warto\u015b\u0107 jaka jest dodawana do ka\u017cdego wy\u015bwietlanego znaku, np. TextAttr = $80 spowoduje \u017ce znaki b\u0119d\u0105 wy\u015bwietlane w inwersie. WhereX WhereX: byte absolute $54; Zmienna przechowuje aktualn\u0105 poziom\u0105 pozycj\u0119 kursora. WhereY WhereY: byte absolute $55; Zmienna przechowuje aktualn\u0105 pionow\u0105 pozycj\u0119 kursora. Procedures and functions ClrEol ClrScr CursorOff CursorOn Delay DelLine GotoXY InsLine Keypressed NoSound ReadKey Sound TextBackground TextColor ClrEol procedure ClrEol; Procedura czy\u015bci wiersz od aktualnej pozycji kursora do prawej strony kraw\u0119dzi ekranu. Pozycja kursora nie ulega zmianie. ClrScr procedure ClrScr; Procedura czy\u015bci ekran edytora, wykonuje kod znaku CH_CLR . CursorOff procedure CursorOff; Procedura wy\u0142\u0105cza kursor. CursorOn procedure CursorOn; Procedura w\u0142\u0105cza kursor. Delay procedure Delay(MS: Word); Procedura czeka zadan\u0105 ilo\u015b\u0107 milisekund MS . W przybli\u017ceniu Delay(1000) generuje op\u00f3\u017anienie jednej sekundy. DelLine procedure DelLine; Procedura kasuje wiersz na aktualnej pozycji kursora, wykonuje kod znaku CH_DELLINE . GotoXY procedure GotoXY(x, y: byte); Procedura ustawia now\u0105 pozycj\u0119 kursora. InsLine procedure InsLine; Procedura wstawia pusty wiersz na aktualnej pozycji kursora, wykonuje kod znaku CH_INSLINE . Keypressed function Keypressed: Boolean; Funkcja zwraca TRUE gdy zosta\u0142 naci\u015bni\u0119ty jaki\u015b klawisz klawiatury, w przeciwnym razie zwraca FALSE . NoSound procedure NoSound; Procedura wycisza kana\u0142y obu POKEY-i $D200 $D210) . ReadKey function ReadKey: char; Funkcja zwraca kod naci\u015bni\u0119tego klawisza klawiatury. Sound procedure Sound(Chan,Freq,Dist,Vol: byte); Procedura odtwarza d\u017awi\u0119k na kanale POKEY-a CHAN (0..3, 4..7) , o cz\u0119stotliwo\u015bci FREQ (0..255) , filtrach DIST (0..7) , g\u0142o\u015bno\u015bci VOL (0..15) . TextBackground procedure TextBackground(a: byte); Procedura ustawia nowy kolor t\u0142a znak\u00f3w (dzia\u0142a najlepiej z w\u0142\u0105czonym VBXE ). TextColor procedure TextColor(a: byte); Procedura ustawia nowy kolor znak\u00f3w (dzia\u0142a najlepiej z w\u0142\u0105czonym VBXE ). GRAPH Constants { graphic drivers } D1bit = 11; D2bit = 12; D4bit = 13; D6bit = 14; // 64 colors Half-brite mode - Amiga D8bit = 15; D12bit = 16; // 4096 color modes HAM mode - Amiga m640x480 = 8 + 16; { error codes } grOK = 0; grNoInitGraph = -1; grNotDetected = -2; grFileNotFound = -3; grInvalidDriver = -4; grNoLoadMem = -5; grNoScanMem = -6; grNoFloodMem = -7; grFontNotFound = -8; grNoFontMem = -9; grInvalidMode = -10; grError = -11; grIOerror = -12; grInvalidFont = -13; grInvalidFontNum = -14; grInvalidVersion = -18; Variables GraphResult GraphResult : byte Procedures and functions Bar Bar3D Circle ClipLine Ellipse FillEllipse FillRect FloodFill GetColor GetMaxX GetMaxY GetPixel GetX GetY InitGraph Line LineTo MoveRel MoveTo PutPixel Rectangle SetBkColor SetClipRect SetColor SetColorMapEntry SetColorMapDimensions Bar procedure Bar(x1, y1, x2, y2: Smallint); Prostok\u0105t, np. dla wykres\u00f3w s\u0142upkowych. Bar3D procedure Bar3D(x1, y1, x2, y2: smallint; depth: word; top: boolean); S\u0142upek dla wykres\u00f3w tr\u00f3jwymiarowych. Circle procedure Circle(x0,y0,radius: word); Okr\u0105g. ClipLine procedure ClipLine(x1, y1, x2, y2: smallint); Ellipse procedure Ellipse(x0, y0, a, b: word); Elipsa. FillEllipse procedure FillEllipse(x0, y0, a, b: word); Elipsa wype\u0142niona wewn\u0105trz. FillRect procedure FillRect(Rect: TRect); Prostok\u0105t wype\u0142niony wewn\u0105trz. FloodFill procedure FloodFill(x, y: smallint; color: byte); Wype\u0142nienie zamkni\u0119tego obszaru ekranu. GetColor function GetColor: byte; assembler; Podaj bie\u017c\u0105cy kolor rysowania. GetMaxX function GetMaxX: word; Podaj najwy\u017csz\u0105 warto\u015b\u0107 wsp\u00f3\u0142rz\u0119dnej X na ekranie. GetMaxY function GetMaxY: word; Podaj najwy\u017csz\u0105 warto\u015b\u0107 wsp\u00f3\u0142rz\u0119dnej Y na ekranie. GetPixel function GetPixel(x,y: smallint): byte; Podaj kolor danego punktu na ekranie. GetX function GetX: smallint; Podaj bie\u017c\u0105c\u0105 wsp\u00f3\u0142rz\u0119dn\u0105 X kursora graficznego. GetY function GetY: smallint; Podaj bie\u017c\u0105c\u0105 wsp\u00f3\u0142rz\u0119dn\u0105 Y kursora graficznego. InitGraph procedure InitGraph(mode: byte); procedure InitGraph(driver, mode: byte; pth: TString); Zainicjuj tryb graficzny. Line procedure Line(x0, y0, x1, y1: smallint); Linia prosta. LineTo procedure LineTo(x, y: smallint); Linia od bie\u017c\u0105cej pozycji kursora do wskazanego punktu. MoveRel procedure MoveRel(Dx, Dy: smallint); Przesu\u0144 kursor graficzny. MoveTo procedure MoveTo(x, y: smallint); Przesu\u0144 kursor graficzny do wskazanego punktu. PutPixel procedure PutPixel(x,y: smallint); procedure PutPixel(x,y: smallint; color: byte); Zapal punkt na ekranie. Rectangle procedure Rectangle(x1, y1, x2, y2: smallint); procedure Rectangle(Rect: TRect); Prostok\u0105t. SetBkColor procedure SetBkColor(color: byte); Ustaw kolor t\u0142a. SetClipRect procedure SetClipRect(x0,y0,x1,y1: smallint); procedure SetClipRect(Rect: TRect); SetColor procedure SetColor(color: byte); Ustaw kolor pisaka. SetColorMapEntry procedure SetColorMapEntry; procedure SetColorMapEntry(a,b,c: byte); SetColorMapDimensions procedure SetColorMapDimensions(w,h: byte); SYSUTILS Constants faReadOnly = $01; faHidden = $02; faSysFile = $04; faVolumeID = $08; faDirectory = $10; faArchive = $20; faAnyFile = $3f; Types TSearchRec TSearchRec = record Attr: Byte; Name: TString; FindHandle: Pointer; end; Procedures and functions AnsiUpperCase Beep Click DeleteFile ExtractFileExt FileExists FindFirst FindNext FindClose GetTickCount IntToHex IntToStr RenameFile StrToFloat StrToInt AnsiUpperCase function AnsiUpperCase(const a: string): string; Funkcja konwertuje znaki z \u0142a\u0144cucha a na wielkie. Beep procedure Beep; Sygna\u0142 brz\u0119czka (buzzer). Click procedure Click; Sygna\u0142 klawiatury. DeleteFile function DeleteFile(var FileName: TString): Boolean; Funkcja kasuje plik okre\u015blony w parametrze FileName , zwraca TRUE gdy operacja si\u0119 powiod\u0142a. ExtractFileExt function ExtractFileExt(const FileName: string): TString; Na podstawie nazwy pliku lub pe\u0142nej \u015bcie\u017cki do pliku okre\u015blonej w parametrze FileName , funkcja zwraca rozszerzenie (poprzedzone kropk\u0105 - np. .txt ). FileExists function FileExists(const FileName: string): Boolean; Funkcja sprawdza czy plik okre\u015blony w parametrze FileName , istnieje True czy te\u017c nie False . FindFirst function FindFirst(const FileMask: TString; Attributes: Byte; var SearchResult: TSearchRec): byte; Funkcja wyszukuje pliki pasuj\u0105ce do wzorca FileMask i posiadaj\u0105ce atrybuty okre\u015blone w Attributes . Je\u015bli zosta\u0142y znalezione pliki pasuj\u0105ce do szablonu to pierwszy z nich jest zwracany w zmiennej SerchResult . FindNext function FindNext(var f: TSearchRec): byte; Funkcja przechodzi do nast\u0119pnego rekordu znalezionego wcze\u015bniej przy pomocy FindFirst . W parametrze musi zosta\u0107 przekazane wskazanie na rekord, kt\u00f3ry wcze\u015bniej zosta\u0142 u\u017cyty w funkcji FindFirst . FindClose procedure FindClose(var f: TSearchRec); Procedura zwalnia zasoby (pami\u0119\u0107) zaalokowan\u0105 przez funkcj\u0119 FindFirst . Procedura ta powinna by\u0107 wywo\u0142ywana za ka\u017cdym razem po zako\u0144czeniu procesu wyszukiwania. GetTickCount function GetTickCount: cardinal; GetTickCount zwraca 24-bitowy licznik czasu (PEEK(RTCLOK+2) + PEEK(RTCLOK+1)*256 + PEEK(RTCLOK)*65536) . Jest to przydatne do pomiaru czasu. IntToHex function IntToHex(Value: cardinal; Digits: byte): TString; Funkcja konwertuje warto\u015b\u0107 liczbow\u0105 na jej odpowiednik \u0142a\u0144cuchowy w systemie szesnastkowym. IntToStr function IntToStr(a: integer): ^char; Funkcja s\u0142u\u017cy do konwersji liczby ca\u0142kowitej podanej w parametrze do postaci \u0142a\u0144cuchowej. RenameFile function RenameFile(var OldName,NewName: TString): Boolean; Funkcja pr\u00f3buje zmieni\u0107 nazw\u0119 pliku okre\u015blonego w parametrze OldName na NewName . Je\u017celi operacja si\u0119 powiedzie, funkcja zwr\u00f3ci warto\u015b\u0107 True w przeciwnym wypadku False . Mo\u017ce si\u0119 zdarzy\u0107, \u017ce funkcja nie b\u0119dzie mog\u0142a zmieni\u0107 nazwy (np. gdy aplikacja nie ma prawa do tego) - w\u00f3wczas funkcja zwr\u00f3ci False . StrToFloat function StrToFloat(var s: TString): real; Funkcja konwertuje \u0142a\u0144cuch do postaci zmiennoprzenkowej typu Real . StrToInt function StrToInt(const S: char): byte; function StrToInt (const S: TString): integer; Funkcja s\u0142u\u017cy do konwersji tekstu zapisanego w zmiennej S na liczb\u0119 ca\u0142kowit\u0105 - o ile to mo\u017cliwe. VBXE Mapa pami\u0119ci dla VBXE zdefiniowana jest w module SYSTEM . VBXE_XDLADR = $0000; // XDLIST VBXE_MAPADR = $1000; // COLOR MAP ADDRESS VBXE_BCBADR = $0100; // BLITTER LIST ADDRESS VBXE_OVRADR = $5000; // OVERLAY ADDRESS VBXE_WINDOW = $B000; // 4K WINDOW $B000..$BFFF Constants LoRes = 1; // 160x240x256c MedRes = 2; // 320x240x256c HiRes = 3; // 640x240x16c Types TUInt24 record byte0: byte; byte1: byte; byte2: byte; end; Typ 24-bitowy wykorzystywany do definicji adres\u00f3w pami\u0119ci VBXE . TXDL record xdlc_: word; rptl_: byte; xdlc: word; rptl: byte; ov_adr: TUInt24; ov_step: word; mp_adr: TUInt24; mp_step: word; mp_hscrol: byte; mp_vscrol: byte; mp_width: byte; mp_height: byte; ov_width: byte; ov_prior: byte; end; Typ TXDL wykorzystywany przez procedury GetXDL i SetXDL . Pozwala na modyfikacj\u0119 programu dla VBXE wykorzystywanego przez MP . TBCB record src_adr: TUInt24; src_step_y: smallint; src_step_x: shortint; dst_adr: TUInt24; dst_step_y: smallint; dst_step_x: shortint; blt_width: word; blt_height: byte; blt_and_mask: byte; blt_xor_mask: byte; blt_collision_mask: byte; blt_zoom: byte; pattern_feature: byte; blt_control: byte; end; Typ TBCB (21 bajt\u00f3w), Blitter Code Block . Definicja typu bloku programu dla Blittera VBXE . TVBXEMemoryStream Object Position: cardinal; Size: cardinal; // 0..Size-1 procedure Create; procedure Clear; procedure SetBank; procedure ReadBuffer(var Buffer; Count: word); procedure WriteBuffer(var Buffer; Count: word); function ReadByte: Byte; function ReadWord: Word; function ReadDWord: Cardinal; procedure WriteByte(b: Byte); procedure WriteWord(w: Word); procedure WriteDWord(d: Cardinal); end; Obiekt TVBXEMemoryStream pozwala na liniowy dost\u0119p do pami\u0119ci VBXE . Procedures and functions BlitterBusy ColorMapOff ColorMapOn DstBCB ExtractFileExt GetXDL IniBCB OverlayOff RunBCB SetHorizontalRes VBXEMemoryBank SetXDL SrcBCB VBXEControl VBXEOff BlitterBusy function BlitterBusy: Boolean; assembler; Funkcja zwraca TRUE je\u015bli blitter VBXE zaj\u0119ty jest wykonywaniem programu blittera. ColorMapOff procedure ColorMapOff; assembler; Wy\u0142\u0105czenie mapy kolor\u00f3w w programie XDLIST dla VBXE . ColorMapOn procedure ColorMapOn; assembler; W\u0142\u0105czenie mapy kolor\u00f3w w programie XDLIST dla VBXE . DstBCB procedure DstBCB(var a: TBCB; dst: cardinal); Procedura zmieniaj\u0105ca adres docelowy dst_adr w programie blittera A . GetXDL procedure GetXDL(var a: txdl); register; assembler; Procedura przepisuje do zmiennej A program XDLIST spod adresu VBXE_XDLADR w pami\u0119ci VBXE . IniBCB procedure IniBCB(var a: TBCB; src,dst: cardinal; w0, w1: smallint; w: word; h: byte; ctrl: byte); Procedura pozwala zaincjowa\u0107 pami\u0119\u0107 dla programu blittera pod adresem A . Dodatkowe parametry okre\u015blaj\u0105 adres spod kt\u00f3rego b\u0119d\u0105 kopiowane dane SRC , adres docelowy kopiowanych danych DST , szeroko\u015b\u0107 okna danych \u017ar\u00f3d\u0142owych W0 , docelowych W1 , rozmiar okna wynikowego, jego szeroko\u015b\u0107 W , wysoko\u015b\u0107 H , oraz okre\u015bli\u0107 parametry ko\u0144cowe bloku programu blittera CTRL (ustawiony bit 3 CTRL nakazuje blitterowi odczyt kolejnego programu i jego wykonanie). OverlayOff procedure OverlayOff; assembler; Wy\u0142\u0105czenie trybu overlay w programie XDLIST . RunBCB procedure RunBCB(var a: TBCB); assembler; Wystartowanie blittera VBXE na podstawie adresu programu A . SetHorizontalRes procedure SetHorizontalRes(a: byte); assembler; procedure SetHRes(a: byte); assembler; Ustanowienie trybu overlay w programie XDLIST . VBXEMemoryBank procedure VBXEMemoryBank(b: byte); assembler; W\u0142\u0105czenie 4K banku VBXE w okno pami\u0119ci XE/XL $B000..$BCFF . SetXDL procedure SetXDL(var a: txdl); register; assembler; Procedura przepisuje program A pod adres VBXE_XDLADR w pami\u0119ci VBXE . SrcBCB procedure SrcBCB(var a: TBCB; src: cardinal); Procedura zmieniaj\u0105ca adres \u017ar\u00f3d\u0142owy src_adr w programie blittera A . VBXEControl procedure VBXEControl(a: byte); assembler; Procedura ustawia warto\u015bc FX_VIDEO_CONTROL . VBXEOff procedure VBXEOff Wy\u0142\u0105czenie, reset VBXE . MATH Procedures and functions ArcCos ArcSin ArcTan2 Ceil CycleToRad DegNormalize DegToGrad DegToRad DivMod EnsureRange Floor FMod GradToDeg GradToRad InRange IsNan Log2 Log10 LogN Max Min Power RadToCycle RadToDeg RadToGrad RandG RandomRange RandomRangeF Tan ArcCos function ArcCos(x: real): real; ArcCos jest funkcj\u0105 odwrotn\u0105 do funkcji Cos . Warto\u015b\u0107 parametru X musi nale\u017ce\u0107 do przedzia\u0142u obustronnie domkni\u0119tego <-1; 1> . Warto\u015bci\u0105 zwracan\u0105 przez funkcj\u0119 jest k\u0105t z przedzia\u0142u <0; ?> wyra\u017cony w mierze \u0142ukowej (radianach). ArcSin function ArcSin(x: real): real; Funkcja s\u0142u\u017cy do obliczenia funkcji matematycznej arcus sinus z liczby X . Jest to funkcja odwrotna do funkcji sinus, tzn. sin(arcsin(x)) = x . ArcTan2 function ArcTan2(y, x: real) : real; Funkcja oblicza arcus tangens (odwrotno\u015b\u0107 tangensa) z liczby Y/X i zwraca warto\u015b\u0107 w radianach. Ceil function Ceil(a: real): smallint; Funkcja zwraca najmniejsz\u0105 liczb\u0119 ca\u0142kowit\u0105 wi\u0119ksz\u0105 lub r\u00f3wn\u0105 od tej podanej w parametrze. CycleToRad function CycleToRad(cycle : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w cyklach (obrotach) na k\u0105t wyra\u017cony w radianach. DegNormalize function DegNormalize(deg : real) : real; DegToGrad function DegToGrad(deg : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w stopniach na k\u0105t wyra\u017cony w gradach. DegToRad function DegToRad(deg : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w stopniach na k\u0105t wyra\u017cony w mierze \u0142ukowej, czyli radianach. DivMod procedure DivMod(Dividend: integer; Divisor: Word; var r, Remainder: Word); procedure DivMod(Dividend: integer; Divisor: Word; var r, Remainder: smallint); EnsureRange function EnsureRange(const AValue, AMin, AMax: byte): Integer; function EnsureRange(const AValue, AMin, AMax: Integer): Integer; Floor function Floor(a: real): smallint; Funkcja zwraca najbli\u017csz\u0105 liczb\u0119 ca\u0142kowit\u0105 mniejsz\u0105 lub r\u00f3wn\u0105 od tej podanej w parametrze. FMod function FMod(a, b: real): real; Funkcja zwraca reszt\u0119 z dzielenia dw\u00f3ch liczb rzeczywistych. GradToDeg function GradToDeg(grad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w gradach na k\u0105t wyra\u017cony w stopniach. GradToRad function GradToRad(grad : real) : real; Funkcja GradToRad przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w gradach na k\u0105t wyra\u017cony w radianach. InRange function InRange(const AValue, AMin, AMax: byte): Boolean; function InRange(const AValue, AMin, AMax: Integer): Boolean; IsNan function IsNan(const d : Single): Boolean; Funkcja sprawdza czy warto\u015b\u0107 parametru d jest poprawn\u0105 liczb\u0105. Log2 function log2(x : single): single; Funkcja zwraca warto\u015b\u0107 logarytmu przy podstawie 2 dla parametru rzeczywistego X>0. Log10 function log10(x : single): single; Funkcja zwraca warto\u015b\u0107 logarytmu dziesi\u0119tnego (logarytmu przy podstawie 10) dla parametru rzeczywistego X>0. LogN function logN(n,x : single): single; Funkcja zwraca warto\u015b\u0107 logarytmu przy podstawie N>0 dla parametru rzeczywistego X>0. Max function Max(a, b: real): real; function Max(a, b: integer): integer; Przeci\u0105\u017cona funkcja por\u00f3wnuje warto\u015bci dw\u00f3ch parametr\u00f3w: a i b , oraz zwraca ten, kt\u00f3ry jest wi\u0119kszy. Min function Min(a, b: real): real; function Min(a, b: integer): integer; Przeci\u0105\u017cona funkcja por\u00f3wnuje warto\u015bci dw\u00f3ch parametr\u00f3w a i b , oraz zwraca warto\u015b\u0107 tego kt\u00f3ry jest mniejszy. Power function Power(base : real; const exponent : shortint): real; power(base : integer; const exponent : shortint): integer; Funkcja podnosi liczb\u0119 A do dowolnej pot\u0119gi N, pot\u0119ga mo\u017ce by\u0107 u\u0142amkiem. RadToCycle function RadToCycle(rad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w radianach na k\u0105t wyra\u017cony w cyklach (obrotach). RadToDeg function RadToDeg(rad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w radianach na k\u0105t wyra\u017cony w stopniach (deg). RadToGrad function RadToGrad(rad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w radianach na k\u0105t wyra\u017cony w gradach. RandG function RandG(mean, StdDev : single) : single; RandG reprezentuje generator liczb pseudolosowych o rozk\u0142adzie Gaussa wok\u00f3\u0142 \u015bredniej mean . Parametr StdDev jest odchyleniem standardowym generowanych liczb od warto\u015bci \u015bredniej mean . RandomRange function RandomRange(const aFrom, aTo: smallint): smallint; Funkcja zwraca losow\u0105 liczb\u0119 z przedzia\u0142u AFrom - ATo , \u0142\u0105cznie z warto\u015bci\u0105 ATo . RandomRangeF function RandomRangeF(const min, max: single): single; Tan function Tan(x: Real): Real; Funkcja zwraca warto\u015b\u0107 tangensa k\u0105ta podanego w parametrze x .","title":"Essential Libraries"},{"location":"essential-libraries/#_1","text":"W katalogu LIB Mad-Pascala znajduj\u0105 si\u0119 potrzebne do kompilacji podstawowe modu\u0142y UNIT , takie jak SYSTEM CRT GRAPH SYSUTILS MATH DOS . W programie wybierane s\u0105 przez instrukcj\u0119 USES , np.: uses crt, sysutils; Modu\u0142 SYSTEM jest domy\u015blnie dopisywany do listy USES i kompilowany jako pierwszy.","title":""},{"location":"essential-libraries/#system","text":"","title":"SYSTEM"},{"location":"essential-libraries/#constants","text":"M_PI_2 = 6.283285; // pi * 2 D_PI_2 = 1.570796; // pi / 2 D_PI_180 = 0.017453; // pi / 180 mGTIA = 0; mVBXE = $80; WINDOW = $10; NARROW = $20; VBXE_XDLADR = $0000; // XDLIST VBXE_MAPADR = $1000; // COLOR MAP ADDRESS VBXE_BCBADR = $0100; // BLITTER LIST ADDRESS VBXE_OVRADR = $5000; // OVERLAY ADDRESS VBXE_WINDOW = $B000; // 4K WINDOW $B000..$BFFF iDLI = 0; iVBL = 1; CH_DELCHR = $FE; CH_ENTER = $9B; CH_ESC = $1B; CH_CURS_UP = 28; CH_CURS_DOWN = 29; CH_CURS_LEFT = 30; CH_CURS_RIGHT = 31; CH_TAB = $7F; CH_EOL = $9B; CH_CLR = $7D; CH_BEL = $FD; CH_DEL = $7E; CH_DELLINE = $9C; CH_INSLINE = $9D; COLOR_BLACK = $00; COLOR_WHITE = $0e; COLOR_RED = $32; COLOR_CYAN = $96; COLOR_VIOLET = $68; COLOR_GREEN = $c4; COLOR_BLUE = $74; COLOR_YELLOW = $ee; COLOR_ORANGE = $4a; COLOR_BROWN = $e4; COLOR_LIGHTRED = $3c; COLOR_GRAY1 = $04; COLOR_GRAY2 = $06; COLOR_GRAY3 = $0a; COLOR_LIGHTGREEN = $cc; COLOR_LIGHTBLUE = $7c;","title":"Constants"},{"location":"essential-libraries/#types","text":"","title":"Types"},{"location":"essential-libraries/#tpoint","text":"TPoint = record x,y: SmallInt end; Definicja wsp\u00f3\u0142rz\u0119dnych (x,y).","title":"TPoint"},{"location":"essential-libraries/#trect","text":"TRect = record left, top, right, bottom: smallint end; Definicja po\u0142o\u017cenia i rozmiaru czworok\u0105ta o parametrach (left, top) - lewy g\u00f3rny naro\u017cnik, (right, bottom) - prawy dolny naro\u017cnik.","title":"TRect"},{"location":"essential-libraries/#tstring","text":"TString = string[32]; Definicja kr\u00f3tkiego ci\u0105gu znakowego wykorzystywanego do przekazywania nazw plik\u00f3w itp.","title":"TString"},{"location":"essential-libraries/#variables","text":"","title":"Variables"},{"location":"essential-libraries/#ioresult","text":"IOResult: byte; Zmienna przechowuje ostatni b\u0142\u0105d operacji I/O . Kody b\u0142\u0119d\u00f3w I/O .","title":"IOResult"},{"location":"essential-libraries/#screenwidth","text":"ScreenWidth: word = 40 Zmienna przechowuj\u0105ca aktualn\u0105 szeroko\u015b\u0107 ekranu. Domy\u015blnie jest to warto\u015b\u0107 40 dla ekranu edytora. ScreenHeight: word = 24;","title":"ScreenWidth"},{"location":"essential-libraries/#screenheight","text":"Zmienna przechowuj\u0105\u0107a aktualn\u0105 wysoko\u015b\u0107 ekranu. Domy\u015blnie jest to warto\u015b\u0107 24 dla ekranu edytora.","title":"ScreenHeight"},{"location":"essential-libraries/#procedures-and-functions","text":"Abs ArcTan Assign BinStr Concat Blockread Blockwrite Chr Cos Close Dec DeleteFile DPeek DPoke Eof Exit Exp FilePos FileSize FillChar Frac GetIntVec Halt Hi HexStr Inc Ln Lo LowerCase Move OctStr Odd Ord ParamCount ParamStr Pause Peek Point PointsEqual Poke Pred Random ReadConfig ReadSecto Rect RenameFile Reset Rewrite Round Seek SetLength SetIntVec Sin Succ Space SizeOf Str StringOfChar Sqr Sqrt Trunc UpCase Val WriteSector","title":"Procedures and functions"},{"location":"essential-libraries/#abs","text":"function Abs(x: real): real; function Abs(x: integer): integer; Funkcja obliczaj\u0105ca warto\u015b\u0107 bezwzgl\u0119dn\u0105 podanej liczby (ang. Absolute value ). Warto\u015b\u0107 bezwzgl\u0119dna liczby nieujemnej to ta sama liczba, a liczby ujemnej - liczba do niej przeciwna. Funkcja w przypadku podania jej argumentu ca\u0142kowitego zwraca wynik r\u00f3wnie\u017c typu ca\u0142kowitego.","title":"Abs"},{"location":"essential-libraries/#arctan","text":"function ArcTan(x: real): real; Funkcja (arcus tangens) zwraca warto\u015b\u0107 k\u0105ta, kt\u00f3rego tangens wynosi x .","title":"ArcTan"},{"location":"essential-libraries/#assign","text":"procedure Assign(var F:File; FileName:string) Procedura przypisuje zmiennej plikowej F plik o nazwie FileName . Aby m\u00f3c odwo\u0142ywa\u0107 si\u0119 do jakiego\u015b pliku, zawsze nale\u017cy najpierw u\u017cy\u0107 procedury Assign . Przy dalszych operacjach pliki s\u0105 identyfikowane przy pomocy zmiennej plikowej, a nie nazwy.","title":"Assign"},{"location":"essential-libraries/#binstr","text":"function BinStr(Value: cardinal; Digits: byte): TString; Funkcja zwraca ci\u0105g znakowy z reprezentacj\u0105 binarn\u0105 warto\u015bci Value . Digits okre\u015bla d\u0142ugo\u015b\u0107 ci\u0105gu, kt\u00f3ry maksymalnie mo\u017ce liczy\u0107 32 znaki.","title":"BinStr"},{"location":"essential-libraries/#concat","text":"function Concat(a,b: string): string; assembler function Concat(a: string; b: char): string; assembler; function Concat(a: char; b: string): string; assembler; function Concat(a,b: char): string; Funkcja \u0142\u0105czy dwa ci\u0105gi tekstowe w nowy ci\u0105g znakowy.","title":"Concat"},{"location":"essential-libraries/#blockread","text":"procedure BlockRead(var f: file; var Buf; Count: word; var Result: word); Procedura wczytuje z pliku plik do zmiennej Buf nie wi\u0119cej ni\u017c Count bajt\u00f3w i umieszcza w zmiennej Result ilo\u015b\u0107 rzeczywi\u015bcie przeczytanych bajt\u00f3w (kt\u00f3ra mo\u017ce by\u0107 mniejsza od oczekiwanej np. ze wzgl\u0119du na rzeczywist\u0105 d\u0142ugo\u015b\u0107 pliku).","title":"Blockread"},{"location":"essential-libraries/#blockwrite","text":"procedure BlockWrite(var f: file; var Buf; Count: word; var Result: word); Procedura zapisuje do pliku ze zmiennej Buf nie wi\u0119cej ni\u017c Count bajt\u00f3w.","title":"Blockwrite"},{"location":"essential-libraries/#chr","text":"Chr(65); // Zwraca znak A Chr(90); // Zwraca znak Z Chr(32); // Zwraca znak spacji Writeln(#65); // Znak A Writeln(#65#32#65); // Napisze 'A Z' Funkcja zwraca znak Char o odpowiadaj\u0105cym kodzie ATASCII podanym w parametrze. Zamiennie z funkcj\u0105 Chr , chc\u0105c uzyska\u0107 odpowiedni znak mo\u017cemy u\u017cy\u0107 jego kodu ATASCII poprzedzaj\u0105c go # .","title":"Chr"},{"location":"essential-libraries/#cos","text":"function Cos(x: real): real; Cosinus k\u0105ta, x w radianach.","title":"Cos"},{"location":"essential-libraries/#close","text":"procedure Close(var f: file); Procedura s\u0142u\u017c\u0105ca do zamykania otwartego pliku dowolnego typu. Ka\u017cdy plik otwarty przy pomocy Reset lub Rewrite powinno si\u0119 zamkn\u0105\u0107 przy pomocy Close .","title":"Close"},{"location":"essential-libraries/#dec","text":"procedure Dec(var X [, N: int]); Procedura zmniejsza warto\u015b\u0107 parametru X o 1 lub warto\u015b\u0107 parametru N . Warto\u015b\u0107 parametru X mo\u017ce by\u0107 typu CHAR BYTE WORD CARDINAL . Procedura DEC generuje optymalny kod, jest zalecana do u\u017cywania w p\u0119tlach, zamiast operatora odejmowania - . dec(tmp); dec(tmp[2]);","title":"Dec"},{"location":"essential-libraries/#deletefile","text":"function DeleteFile(FileName: string): Boolean; Funkcja pozwala skasowa\u0107 plik z dysku o nazwie FileName , zwraca TRUE kiedy operacja powiod\u0142a si\u0119, FALSE w przypadku wyst\u0105pienia b\u0142\u0119du (najcz\u0119\u015bciej z powodu zabezpieczenia przed zapisem lub b\u0142\u0119dnej nazwy pliku).","title":"DeleteFile"},{"location":"essential-libraries/#dpeek","text":"function DPeek(a: word): word; Funkcja zwraca s\u0142owo spod adresu a .","title":"DPeek"},{"location":"essential-libraries/#dpoke","text":"procedure DPoke(a: word; value: word); Procedura zapisuje s\u0142owo value pod adresem a .","title":"DPoke"},{"location":"essential-libraries/#eof","text":"function Eof(var f: file): Boolean; Funkcja zwraca warto\u015b\u0107 logiczn\u0105 TRUE je\u015bli osi\u0105gni\u0119ty zosta\u0142 koniec pliku.","title":"Eof"},{"location":"essential-libraries/#exit","text":"Wywo\u0142anie procedury Exit powoduje natychmiastowe opuszczenie bloku programu, w kt\u00f3rym to wywo\u0142anie nast\u0105pi\u0142o. Mo\u017cna jej u\u017cy\u0107 do opuszczenia p\u0119tli, wyj\u015bcia z procedury/funkcji lub programu g\u0142\u00f3wnego.","title":"Exit"},{"location":"essential-libraries/#exp","text":"function Exp(x: real): real; Funkcja podnosz\u0105ca liczb\u0119 e (=2.71) do pot\u0119gi podanej przez argument x .","title":"Exp"},{"location":"essential-libraries/#filepos","text":"function FilePos(var f: file): cardinal; Funkcja zwraca aktualn\u0105 pozycj\u0119 pliku. Plik nie mo\u017ce by\u0107 tekstowy i musi by\u0107 otwarty (np. poleceniem Reset ). Bity 0..15 zwr\u00f3conej warto\u015bci to numer sektora dysku, bity 16..23 pozycja w sektorze [0..255] . Jest to odpowiednik instrukcji NOTE .","title":"FilePos"},{"location":"essential-libraries/#filesize","text":"function FileSize(var f: file): cardinal; Funkcja zwraca d\u0142ugo\u015b\u0107 pliku w bajtach ( Sparta DOS X ). Plik nie mo\u017ce by\u0107 tekstowy i musi by\u0107 otwarty (np. poleceniem Reset ).","title":"FileSize"},{"location":"essential-libraries/#fillchar","text":"procedure FillChar(x: pointer; count: word; value: char); Procedura wype\u0142nia bufor okre\u015blony w parametrze X identycznymi znakami lub bajtami. Parametr value musi okre\u015bla\u0107 dane, natomiast count - ilo\u015b\u0107 danych jakie zostan\u0105 przypisane do bufora. var Buffer : array[0..100] of Char; begin FillChar(Buffer, SizeOf(Buffer), 'A'); end.","title":"FillChar"},{"location":"essential-libraries/#frac","text":"function Frac(x: real): real; Zwraca cz\u0119\u015b\u0107 u\u0142amkow\u0105 liczby x w postaci rzeczywistej.","title":"Frac"},{"location":"essential-libraries/#getintvec","text":"procedure GetIntVec(intno: byte; var vector: pointer); Procedura odczytuje adres wektora przerwa\u0144 wg. kodu INTNO . Obecnie dopuszczalnymi kodami s\u0105: iDLI przerwanie DLI, iVBL przerwanie VBL.","title":"GetIntVec"},{"location":"essential-libraries/#halt","text":"procedure halt; Wywo\u0142anie powoduje natychmiastowe wyj\u015bcie z programu. Mo\u017cna (opcjonalnie) poda\u0107 kod b\u0142\u0119du, w przypadku MP jest on ignorowany.","title":"Halt"},{"location":"essential-libraries/#hi","text":"function Hi(x): byte Funkcja zwracaj\u0105ca starszy bajt parametru x .","title":"Hi"},{"location":"essential-libraries/#hexstr","text":"function HexStr(Value: cardinal; Digits: byte): TString; Funkcja zwraca ci\u0105g znakowy z reprezentacj\u0105 heksadecymaln\u0105 warto\u015bci Value . Digits okre\u015bla d\u0142ugo\u015b\u0107 ci\u0105gu, kt\u00f3ry maksymalnie mo\u017ce liczy\u0107 32 znaki.","title":"HexStr"},{"location":"essential-libraries/#inc","text":"Inc procedure Inc(var X [, N: int]); Procedura zwi\u0119ksza warto\u015b\u0107 parametru X o 1 lub warto\u015b\u0107 parametru N . Warto\u015b\u0107 parametru X mo\u017ce by\u0107 typu CHAR BYTE WORD CARDINAL . Procedura INC generuje optymalny kod, jest zalecana do u\u017cywania w p\u0119tlach, zamiast operatora dodawania + . inc(tmp); inc(tmp[2]);","title":"Inc"},{"location":"essential-libraries/#int","text":"function Int(x: real): real; Funkcja zwraca cz\u0119\u015b\u0107 ca\u0142kowit\u0105 argumentu b\u0119d\u0105cego liczb\u0105 rzeczywist\u0105.","title":"Int"},{"location":"essential-libraries/#ln","text":"function Ln(x: real): real; Funkcja licz\u0105ca logarytm naturalny (o podstawie e) z podanej liczby. Argument funkcji musi by\u0107 dodatni !","title":"Ln"},{"location":"essential-libraries/#lo","text":"function Lo(x): byte; Funkcja zwracaj\u0105ca m\u0142odszy bajt parametru X .","title":"Lo"},{"location":"essential-libraries/#lowercase","text":"function LowerCase(a: char): char; Funkcja zmieniaj\u0105ca znaki 'A'..'Z' na odpowiednie ma\u0142e znaki 'a'..'z'.","title":"LowerCase"},{"location":"essential-libraries/#move","text":"procedure Move(source, dest: pointer; count: word); Procedura s\u0142u\u017cy do kopiowania danych ze \u017ar\u00f3d\u0142a, parametr Source , do bufora oznaczonego jako przeznaczenie, parametr Dest . Ilo\u015b\u0107 kopiowanych danych okre\u015bla parametr Count .","title":"Move"},{"location":"essential-libraries/#octstr","text":"function OctStr(Value: cardinal; Digits: byte): TString; Funkcja zwraca ci\u0105g znakowy z reprezentacj\u0105 \u00f3semkow\u0105 warto\u015bci Value . Digits okre\u015bla d\u0142ugo\u015b\u0107 ci\u0105gu, kt\u00f3ry maksymalnie mo\u017ce liczy\u0107 32 znaki.","title":"OctStr"},{"location":"essential-libraries/#odd","text":"function Odd(x: cardinal): Boolean; function Odd(x: integer): Boolean; Funkcja zwraca warto\u015b\u0107 True je\u017celi liczba okre\u015blona w parametrze X jest nieparzysta, False je\u017celi jest parzysta.","title":"Odd"},{"location":"essential-libraries/#ord","text":"function Ord(X); Funkcja ta dzia\u0142a odwrotnie do Chr . Z podanego znaku jako parametr zwraca nam jego kod w ATASCII . Ord('A'); // Zwraca 65 Ord('Z'); // Zwraca 90 Ord(' '); // Zwraca 32","title":"Ord"},{"location":"essential-libraries/#paramcount","text":"function ParamCount: byte; Funkcja zwraca ilo\u015b\u0107 dost\u0119pnych argument\u00f3w ( Sparta Dos X , BWDos ), tzn. maksymalny indeks dla procedury ParamStr . ParamCount okre\u015bla ilo\u015b\u0107 parametr\u00f3w przekazanych do programu z linii polece\u0144.","title":"ParamCount"},{"location":"essential-libraries/#paramstr","text":"function ParamStr(Index: byte): TString; Funkcja zwraca parametry programu ( Sparta Dos X , BWDos ). Index to numer parametru, czyli ci\u0105gu znak\u00f3w oddzielonego spacj\u0105. Je\u017celi uruchomimy program TEST.EXE w taki spos\u00f3b: TEST.EXE parametr1 parametr2 parametr3 To aby uzyska\u0107 parametr3 nale\u017cy poda\u0107 Index=3 , za\u015b aby uzyska\u0107 parametr1 nale\u017cy Index=1 . Index=0 to specjalny argument, wtedy funkcja zwraca nap\u0119d z kt\u00f3rego zosta\u0142 uruchomiony programu, np. D1: .","title":"ParamStr"},{"location":"essential-libraries/#pause","text":"procedure Pause; procedure Pause(n: word); Procedura zatrzymuje dzia\u0142anie programu na N * 1.50 sek.","title":"Pause"},{"location":"essential-libraries/#peek","text":"function Peek(a: word): byte; Funkcja zwraca bajt spod adresu a .","title":"Peek"},{"location":"essential-libraries/#point","text":"function Point(AX, AY: smallint): TPoint; Funkcja na podstawie parametr\u00f3w AX oraz AY tworzony jest rekord typu TPoint .","title":"Point"},{"location":"essential-libraries/#pointsequal","text":"function PointsEqual(const P1, P2: TPoint): Boolean; Funkcja sprawdza czy warto\u015bci wsp\u00f3\u0142rz\u0119dnych okre\u015blone w parametrach P1 oraz P2 s\u0105 sobie r\u00f3wne. W takim wypadku funkcja zwraca warto\u015b\u0107 True .","title":"PointsEqual"},{"location":"essential-libraries/#poke","text":"procedure Poke(a: word; value: byte); Procedura zapisuje bajt value pod adresem a .","title":"Poke"},{"location":"essential-libraries/#pred","text":"function Pred(X: TOrdinal): TOrdinal; Poprzednik elementu X .","title":"Pred"},{"location":"essential-libraries/#random","text":"function Random: Real; assembler; Funkcja zwraca losow\u0105 warto\u015b\u0107 z przedzia\u0142u <0 .. 1> . function Random(range: byte): byte; assembler; Funkcja zwraca losow\u0105 warto\u015b\u0107 z przedzia\u0142u <0 .. range-1> , w przypadku Range=0 zwraca warto\u015b\u0107 losow\u0105 z przedzia\u0142u <0 .. 255 > . function Random(range: smallint): smallint; Funkcja zwraca losow\u0105 warto\u015b\u0107 z przedzia\u0142u <0 .. range-1> .","title":"Random"},{"location":"essential-libraries/#readconfig","text":"function ReadConfig(devnum: byte): cardinal; Odczyt statusu stacji devnum . Wynikiem s\u0105 cztery bajty DVSTAT ($02EA..$02ED) . Byte 0 ($02ea): Bit 0:Indicates the last command frame had an error. Bit 1:Checksum, indicates that there was a checksum error in the last command or data frame Bit 2:Indicates that the last operation by the drive was in error. Bit 3:Indicates a write protected diskette. 1=Write protect Bit 4:Indicates the drive motor is on. 1=motor on Bit 5:A one indicates MFM format (double density) Bit 6:Not used Bit 7:Indicates Density and a Half if 1 Byte 1 ($02eb): Bit 0:FDC Busy should always be a 1 Bit 1:FDC Data Request should always be 1 Bit 2:FDC Lost data should always be 1 Bit 3:FDC CRC error, a 0 indicates the last sector read had a CRC error Bit 4:FDC Record not found, a 0 indicates last sector not found Bit 5:FDC record type, a 0 indicates deleted data mark Bit 6:FDC write protect, indicates write protected disk Bit 7:FDC door is open, 0 indicates door is open Byte 2 ($2ec): Timeout value for doing a format. Byte 3 ($2ed): not used, should be zero","title":"ReadConfig"},{"location":"essential-libraries/#readsector","text":"procedure ReadSector(devnum: byte; sector: word; var buf); Procedura odczytuje sektora sector dyskietki w stacji dysk\u00f3w devnum i zapisanie go w buforze buf .","title":"ReadSector"},{"location":"essential-libraries/#rect","text":"function Rect(ALeft, ATop, ARight, ABottom: smallint): TRect; Funckja na podstawie parametr\u00f3w tworzy rekord typu TRect .","title":"Rect"},{"location":"essential-libraries/#renamefile","text":"function RenameFile(OldName, NewName: string): Boolean; Funkcja pozwala zmieni\u0107 nazw\u0119 pliku OldName na now\u0105 nazw\u0119 NewName , zwraca TRUE kiedy operacja powiod\u0142a si\u0119, FALSE w przypadku wyst\u0105pienia b\u0142\u0119du (najcz\u0119\u015bciej z powodu zabezpieczenia przed zapisem lub b\u0142\u0119dnej nazwy pliku). RenameFile('D:OLDNAME.TMP', 'NEWNAME.TMP');","title":"RenameFile"},{"location":"essential-libraries/#reset","text":"procedure Reset(var f: file; l: Word); Procedura otwiera istniej\u0105cy plik z nazw\u0105 przekazan\u0105 do F poleceniem Assign . Opcjonalnie mo\u017cemy poda\u0107 rozmiar rekordu w bajtach L , domy\u015blnie jest to warto\u015b\u0107 128.","title":"Reset"},{"location":"essential-libraries/#rewrite","text":"procedure Rewrite(var f: file; l: Word); Procedura tworzy i otwiera nowy plik. f jest nazw\u0105 przekazan\u0105 za pomoc\u0105 polecenia Assign . Opcjonalnie mo\u017cemy poda\u0107 rozmiar rekordu w bajtach l , domy\u015blnie jest to warto\u015b\u0107 128.","title":"Rewrite"},{"location":"essential-libraries/#round","text":"function Round(x: real): integer; Funkcja dokonuje zaokr\u0105glenia podanej liczby rzeczywistej do najbli\u017cszej liczby ca\u0142kowitej.","title":"Round"},{"location":"essential-libraries/#seek","text":"procedure Seek(var f: file; N: cardinal); Procedura ustawia pozycj\u0119 w pliku na N . N powinno by\u0107 warto\u015bci\u0105 zwr\u00f3con\u0105 przez FilePos . Jest to odpowiednik instrukcji POINT .","title":"Seek"},{"location":"essential-libraries/#setlength","text":"procedure SetLength(var S: string; Len: byte); Procedura ustawia d\u0142ugo\u015b\u0107 ci\u0105gu S na LEN .","title":"SetLength"},{"location":"essential-libraries/#setintvec","text":"procedure SetIntVec(intno: Byte; vector: pointer); Procedura ustawia adres wektora przerwa\u0144 wg. kodu INTNO . Obecnie dopuszczalnymi kodami s\u0105: iDLI przerwanie DLI, iVBL przerwanie VBL.","title":"SetIntVec"},{"location":"essential-libraries/#sin","text":"function Sin(x: real): real; Sinus k\u0105ta. x w radianach.","title":"Sin"},{"location":"essential-libraries/#succ","text":"function Succ(X: TOrdinal): TOrdinal; Nast\u0119pnik elementu X .","title":"Succ"},{"location":"essential-libraries/#space","text":"function Space(Len: Byte): ^char; Funkcja generuje nowy ci\u0105g znakowy o d\u0142ugo\u015bci Len wype\u0142niony znakami spacji.","title":"Space"},{"location":"essential-libraries/#sizeof","text":"function SizeOf(X: AnyType): byte; Funkcja zwraca rozmiar podanej zmiennej (lub typu) w bajtach.","title":"SizeOf"},{"location":"essential-libraries/#str","text":"procedure Str(var X: TNumericType; var S: string); Procedura zamienia liczb\u0119 X na \u0142a\u0144cuch znak\u00f3w S .","title":"Str"},{"location":"essential-libraries/#stringofchar","text":"procedure StringOfChar(ch: Char; len: byte): ^char; Funkcja generuje nowy ci\u0105g znakowy o d\u0142ugo\u015bci len wype\u0142niony znakami ch .","title":"StringOfChar"},{"location":"essential-libraries/#sqr","text":"function Sqr(x: real): real; function Sqr(x: integer): integer; Funkcja obliczaj\u0105ca kwadrat podanej liczby (ang. Square ).","title":"Sqr"},{"location":"essential-libraries/#sqrt","text":"function Sqrt(x: real): real; function Sqrt(x: single): single; function Sqrt(x: integer): single; Funkcja obliczaj\u0105ca pierwiastek kwadratowy podanej liczby (ang. Square root ).","title":"Sqrt"},{"location":"essential-libraries/#trunc","text":"function Trunc(x: real): integer; Funkcja zwraca cz\u0119\u015b\u0107 ca\u0142kowit\u0105 liczby rzeczywistej w postaci liczby ca\u0142kowitej.","title":"Trunc"},{"location":"essential-libraries/#upcase","text":"function UpCase(a: char): char; Funkcja zmieniaj\u0105ca znaki 'a'..'z' na odpowiednie du\u017ce znaki 'A'..'Z' .","title":"UpCase"},{"location":"essential-libraries/#val","text":"procedure Val(const S: string; var V; var Code: Byte); Procedura przekszta\u0142ca ci\u0105g znak\u00f3w S na liczb\u0119 V . Code przyjmie warto\u015b\u0107 0 je\u015bli nie by\u0142o b\u0142\u0119dnych znak\u00f3w, w przeciwnym wypadku przyjmie numer znaku kt\u00f3ry spowodowa\u0142 b\u0142\u0105d konwersji.","title":"Val"},{"location":"essential-libraries/#writesector","text":"procedure WriteSector(devnum: byte; sector: word; var buf); Procedura zapisuje sektora sector dyskietki w stacji devnum na podstawie bufora buf .","title":"WriteSector"},{"location":"essential-libraries/#crt","text":"","title":"CRT"},{"location":"essential-libraries/#constants_1","text":"CN_START_SELECT_OPTION = 0; CN_SELECT_OPTION = 1; CN_START_OPTION = 2; CN_OPTION = 3; CN_START_SELECT = 4; CN_SELECT = 5; CN_START = 6; CN_NONE = 7;","title":"Constants"},{"location":"essential-libraries/#variables_1","text":"","title":"Variables"},{"location":"essential-libraries/#consol","text":"Consol: byte absolute $d01f Zmienna zwraca kod naci\u015bni\u0119tego klawisza/klawiszy konsoli.","title":"Consol"},{"location":"essential-libraries/#textattr","text":"TextAttr: byte = 0 Zmienna przechowuje warto\u015b\u0107 jaka jest dodawana do ka\u017cdego wy\u015bwietlanego znaku, np. TextAttr = $80 spowoduje \u017ce znaki b\u0119d\u0105 wy\u015bwietlane w inwersie.","title":"TextAttr"},{"location":"essential-libraries/#wherex","text":"WhereX: byte absolute $54; Zmienna przechowuje aktualn\u0105 poziom\u0105 pozycj\u0119 kursora.","title":"WhereX"},{"location":"essential-libraries/#wherey","text":"WhereY: byte absolute $55; Zmienna przechowuje aktualn\u0105 pionow\u0105 pozycj\u0119 kursora.","title":"WhereY"},{"location":"essential-libraries/#procedures-and-functions_1","text":"ClrEol ClrScr CursorOff CursorOn Delay DelLine GotoXY InsLine Keypressed NoSound ReadKey Sound TextBackground TextColor","title":"Procedures and functions"},{"location":"essential-libraries/#clreol","text":"procedure ClrEol; Procedura czy\u015bci wiersz od aktualnej pozycji kursora do prawej strony kraw\u0119dzi ekranu. Pozycja kursora nie ulega zmianie.","title":"ClrEol"},{"location":"essential-libraries/#clrscr","text":"procedure ClrScr; Procedura czy\u015bci ekran edytora, wykonuje kod znaku CH_CLR .","title":"ClrScr"},{"location":"essential-libraries/#cursoroff","text":"procedure CursorOff; Procedura wy\u0142\u0105cza kursor.","title":"CursorOff"},{"location":"essential-libraries/#cursoron","text":"procedure CursorOn; Procedura w\u0142\u0105cza kursor.","title":"CursorOn"},{"location":"essential-libraries/#delay","text":"procedure Delay(MS: Word); Procedura czeka zadan\u0105 ilo\u015b\u0107 milisekund MS . W przybli\u017ceniu Delay(1000) generuje op\u00f3\u017anienie jednej sekundy.","title":"Delay"},{"location":"essential-libraries/#delline","text":"procedure DelLine; Procedura kasuje wiersz na aktualnej pozycji kursora, wykonuje kod znaku CH_DELLINE .","title":"DelLine"},{"location":"essential-libraries/#gotoxy","text":"procedure GotoXY(x, y: byte); Procedura ustawia now\u0105 pozycj\u0119 kursora.","title":"GotoXY"},{"location":"essential-libraries/#insline","text":"procedure InsLine; Procedura wstawia pusty wiersz na aktualnej pozycji kursora, wykonuje kod znaku CH_INSLINE .","title":"InsLine"},{"location":"essential-libraries/#keypressed","text":"function Keypressed: Boolean; Funkcja zwraca TRUE gdy zosta\u0142 naci\u015bni\u0119ty jaki\u015b klawisz klawiatury, w przeciwnym razie zwraca FALSE .","title":"Keypressed"},{"location":"essential-libraries/#nosound","text":"procedure NoSound; Procedura wycisza kana\u0142y obu POKEY-i $D200 $D210) .","title":"NoSound"},{"location":"essential-libraries/#readkey","text":"function ReadKey: char; Funkcja zwraca kod naci\u015bni\u0119tego klawisza klawiatury.","title":"ReadKey"},{"location":"essential-libraries/#sound","text":"procedure Sound(Chan,Freq,Dist,Vol: byte); Procedura odtwarza d\u017awi\u0119k na kanale POKEY-a CHAN (0..3, 4..7) , o cz\u0119stotliwo\u015bci FREQ (0..255) , filtrach DIST (0..7) , g\u0142o\u015bno\u015bci VOL (0..15) .","title":"Sound"},{"location":"essential-libraries/#textbackground","text":"procedure TextBackground(a: byte); Procedura ustawia nowy kolor t\u0142a znak\u00f3w (dzia\u0142a najlepiej z w\u0142\u0105czonym VBXE ).","title":"TextBackground"},{"location":"essential-libraries/#textcolor","text":"procedure TextColor(a: byte); Procedura ustawia nowy kolor znak\u00f3w (dzia\u0142a najlepiej z w\u0142\u0105czonym VBXE ).","title":"TextColor"},{"location":"essential-libraries/#graph","text":"","title":"GRAPH"},{"location":"essential-libraries/#constants_2","text":"{ graphic drivers } D1bit = 11; D2bit = 12; D4bit = 13; D6bit = 14; // 64 colors Half-brite mode - Amiga D8bit = 15; D12bit = 16; // 4096 color modes HAM mode - Amiga m640x480 = 8 + 16; { error codes } grOK = 0; grNoInitGraph = -1; grNotDetected = -2; grFileNotFound = -3; grInvalidDriver = -4; grNoLoadMem = -5; grNoScanMem = -6; grNoFloodMem = -7; grFontNotFound = -8; grNoFontMem = -9; grInvalidMode = -10; grError = -11; grIOerror = -12; grInvalidFont = -13; grInvalidFontNum = -14; grInvalidVersion = -18;","title":"Constants"},{"location":"essential-libraries/#variables_2","text":"","title":"Variables"},{"location":"essential-libraries/#graphresult","text":"GraphResult : byte","title":"GraphResult"},{"location":"essential-libraries/#procedures-and-functions_2","text":"Bar Bar3D Circle ClipLine Ellipse FillEllipse FillRect FloodFill GetColor GetMaxX GetMaxY GetPixel GetX GetY InitGraph Line LineTo MoveRel MoveTo PutPixel Rectangle SetBkColor SetClipRect SetColor SetColorMapEntry SetColorMapDimensions","title":"Procedures and functions"},{"location":"essential-libraries/#bar","text":"procedure Bar(x1, y1, x2, y2: Smallint); Prostok\u0105t, np. dla wykres\u00f3w s\u0142upkowych.","title":"Bar"},{"location":"essential-libraries/#bar3d","text":"procedure Bar3D(x1, y1, x2, y2: smallint; depth: word; top: boolean); S\u0142upek dla wykres\u00f3w tr\u00f3jwymiarowych.","title":"Bar3D"},{"location":"essential-libraries/#circle","text":"procedure Circle(x0,y0,radius: word); Okr\u0105g.","title":"Circle"},{"location":"essential-libraries/#clipline","text":"procedure ClipLine(x1, y1, x2, y2: smallint);","title":"ClipLine"},{"location":"essential-libraries/#ellipse","text":"procedure Ellipse(x0, y0, a, b: word); Elipsa.","title":"Ellipse"},{"location":"essential-libraries/#fillellipse","text":"procedure FillEllipse(x0, y0, a, b: word); Elipsa wype\u0142niona wewn\u0105trz.","title":"FillEllipse"},{"location":"essential-libraries/#fillrect","text":"procedure FillRect(Rect: TRect); Prostok\u0105t wype\u0142niony wewn\u0105trz.","title":"FillRect"},{"location":"essential-libraries/#floodfill","text":"procedure FloodFill(x, y: smallint; color: byte); Wype\u0142nienie zamkni\u0119tego obszaru ekranu.","title":"FloodFill"},{"location":"essential-libraries/#getcolor","text":"function GetColor: byte; assembler; Podaj bie\u017c\u0105cy kolor rysowania.","title":"GetColor"},{"location":"essential-libraries/#getmaxx","text":"function GetMaxX: word; Podaj najwy\u017csz\u0105 warto\u015b\u0107 wsp\u00f3\u0142rz\u0119dnej X na ekranie.","title":"GetMaxX"},{"location":"essential-libraries/#getmaxy","text":"function GetMaxY: word; Podaj najwy\u017csz\u0105 warto\u015b\u0107 wsp\u00f3\u0142rz\u0119dnej Y na ekranie.","title":"GetMaxY"},{"location":"essential-libraries/#getpixel","text":"function GetPixel(x,y: smallint): byte; Podaj kolor danego punktu na ekranie.","title":"GetPixel"},{"location":"essential-libraries/#getx","text":"function GetX: smallint; Podaj bie\u017c\u0105c\u0105 wsp\u00f3\u0142rz\u0119dn\u0105 X kursora graficznego.","title":"GetX"},{"location":"essential-libraries/#gety","text":"function GetY: smallint; Podaj bie\u017c\u0105c\u0105 wsp\u00f3\u0142rz\u0119dn\u0105 Y kursora graficznego.","title":"GetY"},{"location":"essential-libraries/#initgraph","text":"procedure InitGraph(mode: byte); procedure InitGraph(driver, mode: byte; pth: TString); Zainicjuj tryb graficzny.","title":"InitGraph"},{"location":"essential-libraries/#line","text":"procedure Line(x0, y0, x1, y1: smallint); Linia prosta.","title":"Line"},{"location":"essential-libraries/#lineto","text":"procedure LineTo(x, y: smallint); Linia od bie\u017c\u0105cej pozycji kursora do wskazanego punktu.","title":"LineTo"},{"location":"essential-libraries/#moverel","text":"procedure MoveRel(Dx, Dy: smallint); Przesu\u0144 kursor graficzny.","title":"MoveRel"},{"location":"essential-libraries/#moveto","text":"procedure MoveTo(x, y: smallint); Przesu\u0144 kursor graficzny do wskazanego punktu.","title":"MoveTo"},{"location":"essential-libraries/#putpixel","text":"procedure PutPixel(x,y: smallint); procedure PutPixel(x,y: smallint; color: byte); Zapal punkt na ekranie.","title":"PutPixel"},{"location":"essential-libraries/#rectangle","text":"procedure Rectangle(x1, y1, x2, y2: smallint); procedure Rectangle(Rect: TRect); Prostok\u0105t.","title":"Rectangle"},{"location":"essential-libraries/#setbkcolor","text":"procedure SetBkColor(color: byte); Ustaw kolor t\u0142a.","title":"SetBkColor"},{"location":"essential-libraries/#setcliprect","text":"procedure SetClipRect(x0,y0,x1,y1: smallint); procedure SetClipRect(Rect: TRect);","title":"SetClipRect"},{"location":"essential-libraries/#setcolor","text":"procedure SetColor(color: byte); Ustaw kolor pisaka.","title":"SetColor"},{"location":"essential-libraries/#setcolormapentry","text":"procedure SetColorMapEntry; procedure SetColorMapEntry(a,b,c: byte);","title":"SetColorMapEntry"},{"location":"essential-libraries/#setcolormapdimensions","text":"procedure SetColorMapDimensions(w,h: byte);","title":"SetColorMapDimensions"},{"location":"essential-libraries/#sysutils","text":"","title":"SYSUTILS"},{"location":"essential-libraries/#constants_3","text":"faReadOnly = $01; faHidden = $02; faSysFile = $04; faVolumeID = $08; faDirectory = $10; faArchive = $20; faAnyFile = $3f;","title":"Constants"},{"location":"essential-libraries/#types_1","text":"","title":"Types"},{"location":"essential-libraries/#tsearchrec","text":"TSearchRec = record Attr: Byte; Name: TString; FindHandle: Pointer; end;","title":"TSearchRec"},{"location":"essential-libraries/#procedures-and-functions_3","text":"AnsiUpperCase Beep Click DeleteFile ExtractFileExt FileExists FindFirst FindNext FindClose GetTickCount IntToHex IntToStr RenameFile StrToFloat StrToInt","title":"Procedures and functions"},{"location":"essential-libraries/#ansiuppercase","text":"function AnsiUpperCase(const a: string): string; Funkcja konwertuje znaki z \u0142a\u0144cucha a na wielkie.","title":"AnsiUpperCase"},{"location":"essential-libraries/#beep","text":"procedure Beep; Sygna\u0142 brz\u0119czka (buzzer).","title":"Beep"},{"location":"essential-libraries/#click","text":"procedure Click; Sygna\u0142 klawiatury.","title":"Click"},{"location":"essential-libraries/#deletefile_1","text":"function DeleteFile(var FileName: TString): Boolean; Funkcja kasuje plik okre\u015blony w parametrze FileName , zwraca TRUE gdy operacja si\u0119 powiod\u0142a.","title":"DeleteFile"},{"location":"essential-libraries/#extractfileext","text":"function ExtractFileExt(const FileName: string): TString; Na podstawie nazwy pliku lub pe\u0142nej \u015bcie\u017cki do pliku okre\u015blonej w parametrze FileName , funkcja zwraca rozszerzenie (poprzedzone kropk\u0105 - np. .txt ).","title":"ExtractFileExt"},{"location":"essential-libraries/#fileexists","text":"function FileExists(const FileName: string): Boolean; Funkcja sprawdza czy plik okre\u015blony w parametrze FileName , istnieje True czy te\u017c nie False .","title":"FileExists"},{"location":"essential-libraries/#findfirst","text":"function FindFirst(const FileMask: TString; Attributes: Byte; var SearchResult: TSearchRec): byte; Funkcja wyszukuje pliki pasuj\u0105ce do wzorca FileMask i posiadaj\u0105ce atrybuty okre\u015blone w Attributes . Je\u015bli zosta\u0142y znalezione pliki pasuj\u0105ce do szablonu to pierwszy z nich jest zwracany w zmiennej SerchResult .","title":"FindFirst"},{"location":"essential-libraries/#findnext","text":"function FindNext(var f: TSearchRec): byte; Funkcja przechodzi do nast\u0119pnego rekordu znalezionego wcze\u015bniej przy pomocy FindFirst . W parametrze musi zosta\u0107 przekazane wskazanie na rekord, kt\u00f3ry wcze\u015bniej zosta\u0142 u\u017cyty w funkcji FindFirst .","title":"FindNext"},{"location":"essential-libraries/#findclose","text":"procedure FindClose(var f: TSearchRec); Procedura zwalnia zasoby (pami\u0119\u0107) zaalokowan\u0105 przez funkcj\u0119 FindFirst . Procedura ta powinna by\u0107 wywo\u0142ywana za ka\u017cdym razem po zako\u0144czeniu procesu wyszukiwania.","title":"FindClose"},{"location":"essential-libraries/#gettickcount","text":"function GetTickCount: cardinal; GetTickCount zwraca 24-bitowy licznik czasu (PEEK(RTCLOK+2) + PEEK(RTCLOK+1)*256 + PEEK(RTCLOK)*65536) . Jest to przydatne do pomiaru czasu.","title":"GetTickCount"},{"location":"essential-libraries/#inttohex","text":"function IntToHex(Value: cardinal; Digits: byte): TString; Funkcja konwertuje warto\u015b\u0107 liczbow\u0105 na jej odpowiednik \u0142a\u0144cuchowy w systemie szesnastkowym.","title":"IntToHex"},{"location":"essential-libraries/#inttostr","text":"function IntToStr(a: integer): ^char; Funkcja s\u0142u\u017cy do konwersji liczby ca\u0142kowitej podanej w parametrze do postaci \u0142a\u0144cuchowej.","title":"IntToStr"},{"location":"essential-libraries/#renamefile_1","text":"function RenameFile(var OldName,NewName: TString): Boolean; Funkcja pr\u00f3buje zmieni\u0107 nazw\u0119 pliku okre\u015blonego w parametrze OldName na NewName . Je\u017celi operacja si\u0119 powiedzie, funkcja zwr\u00f3ci warto\u015b\u0107 True w przeciwnym wypadku False . Mo\u017ce si\u0119 zdarzy\u0107, \u017ce funkcja nie b\u0119dzie mog\u0142a zmieni\u0107 nazwy (np. gdy aplikacja nie ma prawa do tego) - w\u00f3wczas funkcja zwr\u00f3ci False .","title":"RenameFile"},{"location":"essential-libraries/#strtofloat","text":"function StrToFloat(var s: TString): real; Funkcja konwertuje \u0142a\u0144cuch do postaci zmiennoprzenkowej typu Real .","title":"StrToFloat"},{"location":"essential-libraries/#strtoint","text":"function StrToInt(const S: char): byte; function StrToInt (const S: TString): integer; Funkcja s\u0142u\u017cy do konwersji tekstu zapisanego w zmiennej S na liczb\u0119 ca\u0142kowit\u0105 - o ile to mo\u017cliwe.","title":"StrToInt"},{"location":"essential-libraries/#vbxe","text":"Mapa pami\u0119ci dla VBXE zdefiniowana jest w module SYSTEM . VBXE_XDLADR = $0000; // XDLIST VBXE_MAPADR = $1000; // COLOR MAP ADDRESS VBXE_BCBADR = $0100; // BLITTER LIST ADDRESS VBXE_OVRADR = $5000; // OVERLAY ADDRESS VBXE_WINDOW = $B000; // 4K WINDOW $B000..$BFFF","title":"VBXE"},{"location":"essential-libraries/#constants_4","text":"LoRes = 1; // 160x240x256c MedRes = 2; // 320x240x256c HiRes = 3; // 640x240x16c","title":"Constants"},{"location":"essential-libraries/#types_2","text":"","title":"Types"},{"location":"essential-libraries/#tuint24","text":"record byte0: byte; byte1: byte; byte2: byte; end; Typ 24-bitowy wykorzystywany do definicji adres\u00f3w pami\u0119ci VBXE .","title":"TUInt24"},{"location":"essential-libraries/#txdl","text":"record xdlc_: word; rptl_: byte; xdlc: word; rptl: byte; ov_adr: TUInt24; ov_step: word; mp_adr: TUInt24; mp_step: word; mp_hscrol: byte; mp_vscrol: byte; mp_width: byte; mp_height: byte; ov_width: byte; ov_prior: byte; end; Typ TXDL wykorzystywany przez procedury GetXDL i SetXDL . Pozwala na modyfikacj\u0119 programu dla VBXE wykorzystywanego przez MP .","title":"TXDL"},{"location":"essential-libraries/#tbcb","text":"record src_adr: TUInt24; src_step_y: smallint; src_step_x: shortint; dst_adr: TUInt24; dst_step_y: smallint; dst_step_x: shortint; blt_width: word; blt_height: byte; blt_and_mask: byte; blt_xor_mask: byte; blt_collision_mask: byte; blt_zoom: byte; pattern_feature: byte; blt_control: byte; end; Typ TBCB (21 bajt\u00f3w), Blitter Code Block . Definicja typu bloku programu dla Blittera VBXE .","title":"TBCB"},{"location":"essential-libraries/#tvbxememorystream","text":"Object Position: cardinal; Size: cardinal; // 0..Size-1 procedure Create; procedure Clear; procedure SetBank; procedure ReadBuffer(var Buffer; Count: word); procedure WriteBuffer(var Buffer; Count: word); function ReadByte: Byte; function ReadWord: Word; function ReadDWord: Cardinal; procedure WriteByte(b: Byte); procedure WriteWord(w: Word); procedure WriteDWord(d: Cardinal); end; Obiekt TVBXEMemoryStream pozwala na liniowy dost\u0119p do pami\u0119ci VBXE .","title":"TVBXEMemoryStream"},{"location":"essential-libraries/#procedures-and-functions_4","text":"BlitterBusy ColorMapOff ColorMapOn DstBCB ExtractFileExt GetXDL IniBCB OverlayOff RunBCB SetHorizontalRes VBXEMemoryBank SetXDL SrcBCB VBXEControl VBXEOff","title":"Procedures and functions"},{"location":"essential-libraries/#blitterbusy","text":"function BlitterBusy: Boolean; assembler; Funkcja zwraca TRUE je\u015bli blitter VBXE zaj\u0119ty jest wykonywaniem programu blittera.","title":"BlitterBusy"},{"location":"essential-libraries/#colormapoff","text":"procedure ColorMapOff; assembler; Wy\u0142\u0105czenie mapy kolor\u00f3w w programie XDLIST dla VBXE .","title":"ColorMapOff"},{"location":"essential-libraries/#colormapon","text":"procedure ColorMapOn; assembler; W\u0142\u0105czenie mapy kolor\u00f3w w programie XDLIST dla VBXE .","title":"ColorMapOn"},{"location":"essential-libraries/#dstbcb","text":"procedure DstBCB(var a: TBCB; dst: cardinal); Procedura zmieniaj\u0105ca adres docelowy dst_adr w programie blittera A .","title":"DstBCB"},{"location":"essential-libraries/#getxdl","text":"procedure GetXDL(var a: txdl); register; assembler; Procedura przepisuje do zmiennej A program XDLIST spod adresu VBXE_XDLADR w pami\u0119ci VBXE .","title":"GetXDL"},{"location":"essential-libraries/#inibcb","text":"procedure IniBCB(var a: TBCB; src,dst: cardinal; w0, w1: smallint; w: word; h: byte; ctrl: byte); Procedura pozwala zaincjowa\u0107 pami\u0119\u0107 dla programu blittera pod adresem A . Dodatkowe parametry okre\u015blaj\u0105 adres spod kt\u00f3rego b\u0119d\u0105 kopiowane dane SRC , adres docelowy kopiowanych danych DST , szeroko\u015b\u0107 okna danych \u017ar\u00f3d\u0142owych W0 , docelowych W1 , rozmiar okna wynikowego, jego szeroko\u015b\u0107 W , wysoko\u015b\u0107 H , oraz okre\u015bli\u0107 parametry ko\u0144cowe bloku programu blittera CTRL (ustawiony bit 3 CTRL nakazuje blitterowi odczyt kolejnego programu i jego wykonanie).","title":"IniBCB"},{"location":"essential-libraries/#overlayoff","text":"procedure OverlayOff; assembler; Wy\u0142\u0105czenie trybu overlay w programie XDLIST .","title":"OverlayOff"},{"location":"essential-libraries/#runbcb","text":"procedure RunBCB(var a: TBCB); assembler; Wystartowanie blittera VBXE na podstawie adresu programu A .","title":"RunBCB"},{"location":"essential-libraries/#sethorizontalres","text":"procedure SetHorizontalRes(a: byte); assembler; procedure SetHRes(a: byte); assembler; Ustanowienie trybu overlay w programie XDLIST .","title":"SetHorizontalRes"},{"location":"essential-libraries/#vbxememorybank","text":"procedure VBXEMemoryBank(b: byte); assembler; W\u0142\u0105czenie 4K banku VBXE w okno pami\u0119ci XE/XL $B000..$BCFF .","title":"VBXEMemoryBank"},{"location":"essential-libraries/#setxdl","text":"procedure SetXDL(var a: txdl); register; assembler; Procedura przepisuje program A pod adres VBXE_XDLADR w pami\u0119ci VBXE .","title":"SetXDL"},{"location":"essential-libraries/#srcbcb","text":"procedure SrcBCB(var a: TBCB; src: cardinal); Procedura zmieniaj\u0105ca adres \u017ar\u00f3d\u0142owy src_adr w programie blittera A .","title":"SrcBCB"},{"location":"essential-libraries/#vbxecontrol","text":"procedure VBXEControl(a: byte); assembler; Procedura ustawia warto\u015bc FX_VIDEO_CONTROL .","title":"VBXEControl"},{"location":"essential-libraries/#vbxeoff","text":"procedure VBXEOff Wy\u0142\u0105czenie, reset VBXE .","title":"VBXEOff"},{"location":"essential-libraries/#math","text":"","title":"MATH"},{"location":"essential-libraries/#procedures-and-functions_5","text":"ArcCos ArcSin ArcTan2 Ceil CycleToRad DegNormalize DegToGrad DegToRad DivMod EnsureRange Floor FMod GradToDeg GradToRad InRange IsNan Log2 Log10 LogN Max Min Power RadToCycle RadToDeg RadToGrad RandG RandomRange RandomRangeF Tan","title":"Procedures and functions"},{"location":"essential-libraries/#arccos","text":"function ArcCos(x: real): real; ArcCos jest funkcj\u0105 odwrotn\u0105 do funkcji Cos . Warto\u015b\u0107 parametru X musi nale\u017ce\u0107 do przedzia\u0142u obustronnie domkni\u0119tego <-1; 1> . Warto\u015bci\u0105 zwracan\u0105 przez funkcj\u0119 jest k\u0105t z przedzia\u0142u <0; ?> wyra\u017cony w mierze \u0142ukowej (radianach).","title":"ArcCos"},{"location":"essential-libraries/#arcsin","text":"function ArcSin(x: real): real; Funkcja s\u0142u\u017cy do obliczenia funkcji matematycznej arcus sinus z liczby X . Jest to funkcja odwrotna do funkcji sinus, tzn. sin(arcsin(x)) = x .","title":"ArcSin"},{"location":"essential-libraries/#arctan2","text":"function ArcTan2(y, x: real) : real; Funkcja oblicza arcus tangens (odwrotno\u015b\u0107 tangensa) z liczby Y/X i zwraca warto\u015b\u0107 w radianach.","title":"ArcTan2"},{"location":"essential-libraries/#ceil","text":"function Ceil(a: real): smallint; Funkcja zwraca najmniejsz\u0105 liczb\u0119 ca\u0142kowit\u0105 wi\u0119ksz\u0105 lub r\u00f3wn\u0105 od tej podanej w parametrze.","title":"Ceil"},{"location":"essential-libraries/#cycletorad","text":"function CycleToRad(cycle : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w cyklach (obrotach) na k\u0105t wyra\u017cony w radianach.","title":"CycleToRad"},{"location":"essential-libraries/#degnormalize","text":"function DegNormalize(deg : real) : real;","title":"DegNormalize"},{"location":"essential-libraries/#degtograd","text":"function DegToGrad(deg : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w stopniach na k\u0105t wyra\u017cony w gradach.","title":"DegToGrad"},{"location":"essential-libraries/#degtorad","text":"function DegToRad(deg : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w stopniach na k\u0105t wyra\u017cony w mierze \u0142ukowej, czyli radianach.","title":"DegToRad"},{"location":"essential-libraries/#divmod","text":"procedure DivMod(Dividend: integer; Divisor: Word; var r, Remainder: Word); procedure DivMod(Dividend: integer; Divisor: Word; var r, Remainder: smallint);","title":"DivMod"},{"location":"essential-libraries/#ensurerange","text":"function EnsureRange(const AValue, AMin, AMax: byte): Integer; function EnsureRange(const AValue, AMin, AMax: Integer): Integer;","title":"EnsureRange"},{"location":"essential-libraries/#floor","text":"function Floor(a: real): smallint; Funkcja zwraca najbli\u017csz\u0105 liczb\u0119 ca\u0142kowit\u0105 mniejsz\u0105 lub r\u00f3wn\u0105 od tej podanej w parametrze.","title":"Floor"},{"location":"essential-libraries/#fmod","text":"function FMod(a, b: real): real; Funkcja zwraca reszt\u0119 z dzielenia dw\u00f3ch liczb rzeczywistych.","title":"FMod"},{"location":"essential-libraries/#gradtodeg","text":"function GradToDeg(grad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w gradach na k\u0105t wyra\u017cony w stopniach.","title":"GradToDeg"},{"location":"essential-libraries/#gradtorad","text":"function GradToRad(grad : real) : real; Funkcja GradToRad przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w gradach na k\u0105t wyra\u017cony w radianach.","title":"GradToRad"},{"location":"essential-libraries/#inrange","text":"function InRange(const AValue, AMin, AMax: byte): Boolean; function InRange(const AValue, AMin, AMax: Integer): Boolean;","title":"InRange"},{"location":"essential-libraries/#isnan","text":"function IsNan(const d : Single): Boolean; Funkcja sprawdza czy warto\u015b\u0107 parametru d jest poprawn\u0105 liczb\u0105.","title":"IsNan"},{"location":"essential-libraries/#log2","text":"function log2(x : single): single; Funkcja zwraca warto\u015b\u0107 logarytmu przy podstawie 2 dla parametru rzeczywistego X>0.","title":"Log2"},{"location":"essential-libraries/#log10","text":"function log10(x : single): single; Funkcja zwraca warto\u015b\u0107 logarytmu dziesi\u0119tnego (logarytmu przy podstawie 10) dla parametru rzeczywistego X>0.","title":"Log10"},{"location":"essential-libraries/#logn","text":"function logN(n,x : single): single; Funkcja zwraca warto\u015b\u0107 logarytmu przy podstawie N>0 dla parametru rzeczywistego X>0.","title":"LogN"},{"location":"essential-libraries/#max","text":"function Max(a, b: real): real; function Max(a, b: integer): integer; Przeci\u0105\u017cona funkcja por\u00f3wnuje warto\u015bci dw\u00f3ch parametr\u00f3w: a i b , oraz zwraca ten, kt\u00f3ry jest wi\u0119kszy.","title":"Max"},{"location":"essential-libraries/#min","text":"function Min(a, b: real): real; function Min(a, b: integer): integer; Przeci\u0105\u017cona funkcja por\u00f3wnuje warto\u015bci dw\u00f3ch parametr\u00f3w a i b , oraz zwraca warto\u015b\u0107 tego kt\u00f3ry jest mniejszy.","title":"Min"},{"location":"essential-libraries/#power","text":"function Power(base : real; const exponent : shortint): real; power(base : integer; const exponent : shortint): integer; Funkcja podnosi liczb\u0119 A do dowolnej pot\u0119gi N, pot\u0119ga mo\u017ce by\u0107 u\u0142amkiem.","title":"Power"},{"location":"essential-libraries/#radtocycle","text":"function RadToCycle(rad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w radianach na k\u0105t wyra\u017cony w cyklach (obrotach).","title":"RadToCycle"},{"location":"essential-libraries/#radtodeg","text":"function RadToDeg(rad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w radianach na k\u0105t wyra\u017cony w stopniach (deg).","title":"RadToDeg"},{"location":"essential-libraries/#radtograd","text":"function RadToGrad(rad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w radianach na k\u0105t wyra\u017cony w gradach.","title":"RadToGrad"},{"location":"essential-libraries/#randg","text":"function RandG(mean, StdDev : single) : single; RandG reprezentuje generator liczb pseudolosowych o rozk\u0142adzie Gaussa wok\u00f3\u0142 \u015bredniej mean . Parametr StdDev jest odchyleniem standardowym generowanych liczb od warto\u015bci \u015bredniej mean .","title":"RandG"},{"location":"essential-libraries/#randomrange","text":"function RandomRange(const aFrom, aTo: smallint): smallint; Funkcja zwraca losow\u0105 liczb\u0119 z przedzia\u0142u AFrom - ATo , \u0142\u0105cznie z warto\u015bci\u0105 ATo .","title":"RandomRange"},{"location":"essential-libraries/#randomrangef","text":"function RandomRangeF(const min, max: single): single;","title":"RandomRangeF"},{"location":"essential-libraries/#tan","text":"function Tan(x: Real): Real; Funkcja zwraca warto\u015b\u0107 tangensa k\u0105ta podanego w parametrze x .","title":"Tan"},{"location":"examples/","text":"Scripts Linux mp-build-a8 #!/bin/bash mp=\"$HOME/Programs/MadPascal/mp\" mads=\"$HOME/Programs/mads/mads\" base=\"$HOME/Programs/MadPascal/base\" if [ -z \"$1\" ]; then echo -e \"\\nPlease call '$0 <argument>' to run this command!\\n\" exit 1 fi name=${1::-4} $mp $name.pas -o if [ -f $name.a65 ]; then [ ! -d \"output\" ] && mkdir output mv $name.a65 output/ $mads output/$name.a65 -x -i:$base -o:output/$name.xex else exit 1 fi if [ ! -z \"$2\" ]; then atari800 output/$name.xex fi mp-build-a8 main.pas r mp-build-c64 #!/bin/bash mp=\"$HOME/Programs/MadPascal/mp\" mads=\"$HOME/Programs/mads/mads\" base=\"$HOME/Programs/MadPascal/base\" if [ -z \"$1\" ]; then echo -e \"\\nPlease call '$0 <argument>' to run this command!\\n\" exit 1 fi name=${1::-4} $mp $name.pas -t c64 -z 10 -o if [ -f $name.a65 ]; then [ ! -d \"output\" ] && mkdir output mv $name.a65 output/ $mads output/$name.a65 -x -i:$base -o:output/$name.prg else exit 1 fi if [ ! -z \"$2\" ]; then x64 output/$name.prg fi mp-build-c64 main.pas r Atari 8-bit Hello World program HelloWorld; uses crt; begin writeln('Hello World'); readkey; end. C64 Test // https://bitbucket.org/paul_nicholls/pas6502/src/master/projects/pas6502_test.dpr program Test; const cScreen0 = 1024; cColor = $d800; var border : Byte absolute $D020; background : Byte absolute $D021; screen0 : array[0..1000-1] of Byte absolute cScreen0; color0 : array[0..1000-1] of Byte absolute cColor; i : Integer; begin i := 0; while i < 1000 do begin // fill screen with all screen codes (wrapping around). screen0[i] := i; // fill color RAM with all colors color0[i] := i; Inc(i); end; end.","title":"Examples"},{"location":"examples/#_1","text":"","title":""},{"location":"examples/#scripts","text":"","title":"Scripts"},{"location":"examples/#linux","text":"","title":"Linux"},{"location":"examples/#mp-build-a8","text":"#!/bin/bash mp=\"$HOME/Programs/MadPascal/mp\" mads=\"$HOME/Programs/mads/mads\" base=\"$HOME/Programs/MadPascal/base\" if [ -z \"$1\" ]; then echo -e \"\\nPlease call '$0 <argument>' to run this command!\\n\" exit 1 fi name=${1::-4} $mp $name.pas -o if [ -f $name.a65 ]; then [ ! -d \"output\" ] && mkdir output mv $name.a65 output/ $mads output/$name.a65 -x -i:$base -o:output/$name.xex else exit 1 fi if [ ! -z \"$2\" ]; then atari800 output/$name.xex fi mp-build-a8 main.pas r","title":"mp-build-a8"},{"location":"examples/#mp-build-c64","text":"#!/bin/bash mp=\"$HOME/Programs/MadPascal/mp\" mads=\"$HOME/Programs/mads/mads\" base=\"$HOME/Programs/MadPascal/base\" if [ -z \"$1\" ]; then echo -e \"\\nPlease call '$0 <argument>' to run this command!\\n\" exit 1 fi name=${1::-4} $mp $name.pas -t c64 -z 10 -o if [ -f $name.a65 ]; then [ ! -d \"output\" ] && mkdir output mv $name.a65 output/ $mads output/$name.a65 -x -i:$base -o:output/$name.prg else exit 1 fi if [ ! -z \"$2\" ]; then x64 output/$name.prg fi mp-build-c64 main.pas r","title":"mp-build-c64"},{"location":"examples/#atari-8-bit","text":"","title":"Atari 8-bit"},{"location":"examples/#hello-world","text":"program HelloWorld; uses crt; begin writeln('Hello World'); readkey; end.","title":"Hello World"},{"location":"examples/#c64","text":"","title":"C64"},{"location":"examples/#test","text":"// https://bitbucket.org/paul_nicholls/pas6502/src/master/projects/pas6502_test.dpr program Test; const cScreen0 = 1024; cColor = $d800; var border : Byte absolute $D020; background : Byte absolute $D021; screen0 : array[0..1000-1] of Byte absolute cScreen0; color0 : array[0..1000-1] of Byte absolute cColor; i : Integer; begin i := 0; while i < 1000 do begin // fill screen with all screen codes (wrapping around). screen0[i] := i; // fill color RAM with all colors color0[i] := i; Inc(i); end; end.","title":"Test"},{"location":"instructions/","text":"Conditional case of else Currently, Mad Pascal only accepts types with a length of 1 byte for the CASE variable: SHORTINT BYTE CHAR BOOLEAN . case a of // for a variable A of type CHAR 'A'..'Z': begin end; '0'..'9': begin end; '+','*': begin end; end; if then else IF conditional instructions can be nested. This is used for more complex conditions. Iterative for to downto do FOR variable := { initial value } TO { final value } DO { instructions to execute } FOR variable := { final value } DOWNTO { initial value } DO { instructions to execute } This instruction is used to organize calculations which are performed a predetermined number of times. The control variable shall be an identifier of the ordinal type and both expressions shall be consistent in terms of assignment with the control variable type. During the TO loop execution, the control variable is assigned the subsequent value in the given type, in the DOWNTO loop, the preceding one. It is prohibited to \"manually\" change the value of a control variable. In case of such an attempt, MP signal an error Illegal assignment to for-loop variable . The compiler makes sure that there is no endless loop so that you can use such a loop without a doubt: for i:=0 to 255 do writeln(i); // for a variable I of type BYTE while do while { condition } do { instructions to execute } This construct is used to organize calculations that will be performed as long as the expression after the word WHILE is true. Such a loop may not be executed even once. while BlitterBusy do; // waiting for the VBXE blitter to finish Limitations for WHILE instructions: while i<=255 do inc(i); // endless loop if I is of type BYTE repeat until repeat { instructions to execute } until { termination condition } This statement cyclically executes other statements between REPEAT and UNTIL until the expression after UNTIL takes the value of TRUE . The effect of the REPEAT loop is very similar to that of the WHILE loop. This loop can also be performed a huge number of times. The only difference is that in the REPEAT loop the end condition is only checked after the instruction is executed. This means that the REPEAT loop will always be done at least once. Only after this iteration will the program check if the loop can be terminated. In the case of the WHILE loop, the condition is checked immediately before it is executed, which may result in the loop never being executed. i:=0; repeat inc(i); until i=0; // the loop will repeat 256 times","title":"Instructions"},{"location":"instructions/#_1","text":"","title":""},{"location":"instructions/#conditional","text":"","title":"Conditional"},{"location":"instructions/#case-of-else","text":"Currently, Mad Pascal only accepts types with a length of 1 byte for the CASE variable: SHORTINT BYTE CHAR BOOLEAN . case a of // for a variable A of type CHAR 'A'..'Z': begin end; '0'..'9': begin end; '+','*': begin end; end;","title":"case of else"},{"location":"instructions/#if-then-else","text":"IF conditional instructions can be nested. This is used for more complex conditions.","title":"if then else"},{"location":"instructions/#iterative","text":"","title":"Iterative"},{"location":"instructions/#for-to-downto-do","text":"FOR variable := { initial value } TO { final value } DO { instructions to execute } FOR variable := { final value } DOWNTO { initial value } DO { instructions to execute } This instruction is used to organize calculations which are performed a predetermined number of times. The control variable shall be an identifier of the ordinal type and both expressions shall be consistent in terms of assignment with the control variable type. During the TO loop execution, the control variable is assigned the subsequent value in the given type, in the DOWNTO loop, the preceding one. It is prohibited to \"manually\" change the value of a control variable. In case of such an attempt, MP signal an error Illegal assignment to for-loop variable . The compiler makes sure that there is no endless loop so that you can use such a loop without a doubt: for i:=0 to 255 do writeln(i); // for a variable I of type BYTE","title":"for to downto do"},{"location":"instructions/#while-do","text":"while { condition } do { instructions to execute } This construct is used to organize calculations that will be performed as long as the expression after the word WHILE is true. Such a loop may not be executed even once. while BlitterBusy do; // waiting for the VBXE blitter to finish Limitations for WHILE instructions: while i<=255 do inc(i); // endless loop if I is of type BYTE","title":"while do"},{"location":"instructions/#repeat-until","text":"repeat { instructions to execute } until { termination condition } This statement cyclically executes other statements between REPEAT and UNTIL until the expression after UNTIL takes the value of TRUE . The effect of the REPEAT loop is very similar to that of the WHILE loop. This loop can also be performed a huge number of times. The only difference is that in the REPEAT loop the end condition is only checked after the instruction is executed. This means that the REPEAT loop will always be done at least once. Only after this iteration will the program check if the loop can be terminated. In the case of the WHILE loop, the condition is checked immediately before it is executed, which may result in the loop never being executed. i:=0; repeat inc(i); until i=0; // the loop will repeat 256 times","title":"repeat until"},{"location":"interrupts/","text":"VBL, DLI Two routines GetIntVec and SetIntVec are dedicated to handle VBL , DLI interrupts. The presence of OS is required for proper operation (disable ROM only by $DEFINE ROMOFF ) GetIntVec GetIntVec(iVBL, pointer); // getting VBL interrupt service program address ($0224) GetIntVec(iDLI, pointer); // getting DLI interrupt service program address ($0200) var oldVBL: pointer; begin GetIntVec(iVBL, oldVBL); end. SetIntVec SetIntVec(iVBL, pointer); // set address of VBL interrupt handler ($0224) SetIntVec(iDLI, pointer); // set address of DLI interrupt handler ($0200) procedure newVBL; interrupt; assembler; asm jmp xitvbv end; begin SetIntVec(iVBL, @newVBL); end. The VBL interrupt is terminated by jumping to the XITVBV address ($E462) which will restore the value of the A X Y CPU6502 registers. IRQ - TIMER1, TIMER2, TIMER4 Two routines GetIntVec and SetIntVec are dedicated to handle IRQ - TIMER1 , TIMER2 , TIMER4 interrupts. The presence of OS is required for proper operation (disable ROM only by $DEFINE ROMOFF ) GetIntVec GetIntVec(iTIM1, pointer); // getting the address of the TIMER 1 interrupt handler ($0210) GetIntVec(iTIM2, pointer); // getting the address of the TIMER 2 interrupt handler ($0212) GetIntVec(iTIM4, pointer); // getting the address of the TIMER 4 interrupt handler ($0214) var oldIRQ: pointer; begin GetIntVec(iTIM4, oldIRQ); end. SetIntVec SetIntVec(iTIM1, pointer); // establishing the address of the TIMER 1 interrupt handler ($0210) SetIntVec(iTIM2, pointer); // establishing the address of the TIMER 2 interrupt handler ($0212) SetIntVec(iTIM4, pointer); // establishing the address of the TIMER 4 interrupt handler ($0214) procedure irq; assembler; interrupt; asm pla end; begin SetIntVec(iTIM4, @irq, 0, 28); repeat until keypressed; SetIntVec(iTIM4, oldIRQ); end. When the system executes a jump to an interrupt service routine, it puts the contents of the accumulator on the stack beforehand; keep this in mind and end the interrupt service with PLA . Additional parameters are required to trigger a new IRQ interrupt, such as the choice of base clock clock_base = [0,1] and frequency rate = [6.255] . Values of rate less than 6 will cause the system to slow down severely, up to a possible suspension. SetIntVec(iTIM1, pointer, clock_base, rate); SetIntVec(iTIM2, pointer, clock_base, rate); SetIntVec(iTIM4, pointer, clock_base, rate);","title":"Interrupt handling"},{"location":"interrupts/#_1","text":"","title":""},{"location":"interrupts/#vbl-dli","text":"Two routines GetIntVec and SetIntVec are dedicated to handle VBL , DLI interrupts. The presence of OS is required for proper operation (disable ROM only by $DEFINE ROMOFF )","title":"VBL, DLI"},{"location":"interrupts/#getintvec","text":"GetIntVec(iVBL, pointer); // getting VBL interrupt service program address ($0224) GetIntVec(iDLI, pointer); // getting DLI interrupt service program address ($0200) var oldVBL: pointer; begin GetIntVec(iVBL, oldVBL); end.","title":"GetIntVec"},{"location":"interrupts/#setintvec","text":"SetIntVec(iVBL, pointer); // set address of VBL interrupt handler ($0224) SetIntVec(iDLI, pointer); // set address of DLI interrupt handler ($0200) procedure newVBL; interrupt; assembler; asm jmp xitvbv end; begin SetIntVec(iVBL, @newVBL); end. The VBL interrupt is terminated by jumping to the XITVBV address ($E462) which will restore the value of the A X Y CPU6502 registers.","title":"SetIntVec"},{"location":"interrupts/#irq-timer1-timer2-timer4","text":"Two routines GetIntVec and SetIntVec are dedicated to handle IRQ - TIMER1 , TIMER2 , TIMER4 interrupts. The presence of OS is required for proper operation (disable ROM only by $DEFINE ROMOFF )","title":"IRQ - TIMER1, TIMER2, TIMER4"},{"location":"interrupts/#getintvec_1","text":"GetIntVec(iTIM1, pointer); // getting the address of the TIMER 1 interrupt handler ($0210) GetIntVec(iTIM2, pointer); // getting the address of the TIMER 2 interrupt handler ($0212) GetIntVec(iTIM4, pointer); // getting the address of the TIMER 4 interrupt handler ($0214) var oldIRQ: pointer; begin GetIntVec(iTIM4, oldIRQ); end.","title":"GetIntVec"},{"location":"interrupts/#setintvec_1","text":"SetIntVec(iTIM1, pointer); // establishing the address of the TIMER 1 interrupt handler ($0210) SetIntVec(iTIM2, pointer); // establishing the address of the TIMER 2 interrupt handler ($0212) SetIntVec(iTIM4, pointer); // establishing the address of the TIMER 4 interrupt handler ($0214) procedure irq; assembler; interrupt; asm pla end; begin SetIntVec(iTIM4, @irq, 0, 28); repeat until keypressed; SetIntVec(iTIM4, oldIRQ); end. When the system executes a jump to an interrupt service routine, it puts the contents of the accumulator on the stack beforehand; keep this in mind and end the interrupt service with PLA . Additional parameters are required to trigger a new IRQ interrupt, such as the choice of base clock clock_base = [0,1] and frequency rate = [6.255] . Values of rate less than 6 will cause the system to slow down severely, up to a possible suspension. SetIntVec(iTIM1, pointer, clock_base, rate); SetIntVec(iTIM2, pointer, clock_base, rate); SetIntVec(iTIM4, pointer, clock_base, rate);","title":"SetIntVec"},{"location":"introduction/","text":"Foreword Mad-Pascal (MP) is a 32-bit Turbo Pascal compiler for Atari XE/XL . By design, it is compatible with the Free Pascal Compilator (FPC) (the -MDelphi switch should be active), which means the possibility of obtaining executable code for XE/XL , PC and every other platform for which FPC exists. MP is not a port of FPC ; it has been written based on of SUB-Pascal (2009), XD-Pascal (2010), the author of which is Vasiliy Tereshkov . A program that works on Atari might have problems on PC if, for example, the pointers have not been initialized with the address of a variable and the program attempts to write to the address $0000 (memory protection fault). The strengths of MP include fast and convenient possibility of inclusion of inline assembly. A program using inline ASM does not work on platforms other than XE/XL . MP uses 64KB of primary memory; TMemoryStream provides usage of extended memory. Variable allocation is static; there is no dynamic memory management. Parameters are passed to functions by value, variable or constant. The available features are: If Case For While Repeat statements Compound statements Label Goto statements Arithmetic and boolean operators Procedures and functions with up to 8 parameters. Returned value of a function is assigned to a predefined RESULT variable Static local variables Primitive data types, all types except the ShortReal/Real type are compatible. Pointers are dereferenced as pointers to Word : Cardinal Word Byte Boolean Char String PChar Integer SmallInt ShortInt Pointer File ShortReal Real (fixed-point) Single (IEEE-754) [Float] One-dimensional and Two-dimensional arrays (with zero lower bound) of any primitive type. Arrays are treated as pointers to their origins (like in C) and can be passed to subroutines as parameters Predefined type string [N] which is equivalent to array [0..N] of Char Type aliases. Records Objects Separate program modules Recursion Compilation To compile the sources of Mad-Pascal , one may use Delphi , provided they happen to have installed Delphi 7.0 or a later version. A more cross-platform way is to use the Free Pascal Compiler (FPC), which can be downloaded from freepascal.org . Launch the installer and choose the directory for the installation of FP . It is crucial not to use the exclamation mark ! or other nonstandard characters in the directory name. If it fails to compile any file, most probably, it is the fault of a nonstandard pathname. The command-line launching the compilation may look as follows (letter case in parameter names matters): fpc -Mdelphi -v -O3 mp.pas -Mdelphi allows for Delphi format file compilation -v shows all error and warning diagnostics -O3 performs code optimization Libraries LIB BLIBS Links Free Pascal Reference Guide MadPascal AtariAge forum MadPascal examples Atari XE/XL Pascal Compilers","title":"Introduction"},{"location":"introduction/#_1","text":"","title":""},{"location":"introduction/#foreword","text":"Mad-Pascal (MP) is a 32-bit Turbo Pascal compiler for Atari XE/XL . By design, it is compatible with the Free Pascal Compilator (FPC) (the -MDelphi switch should be active), which means the possibility of obtaining executable code for XE/XL , PC and every other platform for which FPC exists. MP is not a port of FPC ; it has been written based on of SUB-Pascal (2009), XD-Pascal (2010), the author of which is Vasiliy Tereshkov . A program that works on Atari might have problems on PC if, for example, the pointers have not been initialized with the address of a variable and the program attempts to write to the address $0000 (memory protection fault). The strengths of MP include fast and convenient possibility of inclusion of inline assembly. A program using inline ASM does not work on platforms other than XE/XL . MP uses 64KB of primary memory; TMemoryStream provides usage of extended memory. Variable allocation is static; there is no dynamic memory management. Parameters are passed to functions by value, variable or constant. The available features are: If Case For While Repeat statements Compound statements Label Goto statements Arithmetic and boolean operators Procedures and functions with up to 8 parameters. Returned value of a function is assigned to a predefined RESULT variable Static local variables Primitive data types, all types except the ShortReal/Real type are compatible. Pointers are dereferenced as pointers to Word : Cardinal Word Byte Boolean Char String PChar Integer SmallInt ShortInt Pointer File ShortReal Real (fixed-point) Single (IEEE-754) [Float] One-dimensional and Two-dimensional arrays (with zero lower bound) of any primitive type. Arrays are treated as pointers to their origins (like in C) and can be passed to subroutines as parameters Predefined type string [N] which is equivalent to array [0..N] of Char Type aliases. Records Objects Separate program modules Recursion","title":"Foreword"},{"location":"introduction/#compilation","text":"To compile the sources of Mad-Pascal , one may use Delphi , provided they happen to have installed Delphi 7.0 or a later version. A more cross-platform way is to use the Free Pascal Compiler (FPC), which can be downloaded from freepascal.org . Launch the installer and choose the directory for the installation of FP . It is crucial not to use the exclamation mark ! or other nonstandard characters in the directory name. If it fails to compile any file, most probably, it is the fault of a nonstandard pathname. The command-line launching the compilation may look as follows (letter case in parameter names matters): fpc -Mdelphi -v -O3 mp.pas -Mdelphi allows for Delphi format file compilation -v shows all error and warning diagnostics -O3 performs code optimization","title":"Compilation"},{"location":"introduction/#libraries","text":"LIB BLIBS","title":"Libraries"},{"location":"introduction/#links","text":"Free Pascal Reference Guide MadPascal AtariAge forum MadPascal examples Atari XE/XL Pascal Compilers","title":"Links"},{"location":"macros/","text":"Macros MP allows you to use macros, just like FPC , except that macros are always enabled. {$macro on} {$macro off} {$macro+} {$macro-} The {$macro on} directive is required by FPC , in MP it is retained for compatibility purposes only. Defining a macro {$define label := expression} {$define label(par0, par1 ... par7) := expression} For a definition to be recognized as a macro, the assignment symbol := must occur after the label name and any (par0..par7) parameter list. {$define new_proc := procedure test; begin writeln('ok'); end; } new_proc begin test; end. {$define sum_xi := x:=x+i; } begin sum_xi; end; {$define WIDTH := 80} {$define LEN := ( WIDTH + 10 )} var a: byte; begin a := len * 20; end. Macros with parameters are supported by MP but not by FPC , keep this in mind if you intend to test code on other hardware platforms. {$define SIGN_MASK := $8000} {$define SIGNED_INF_VALUE(x) := ((x and SIGN_MASK) or $7C00)} var a: byte = 11; begin writeln( SIGNED_INF_VALUE(a shl 15) ); end.","title":"Macros"},{"location":"macros/#_1","text":"","title":""},{"location":"macros/#macros","text":"MP allows you to use macros, just like FPC , except that macros are always enabled. {$macro on} {$macro off} {$macro+} {$macro-} The {$macro on} directive is required by FPC , in MP it is retained for compatibility purposes only.","title":"Macros"},{"location":"macros/#defining-a-macro","text":"{$define label := expression} {$define label(par0, par1 ... par7) := expression} For a definition to be recognized as a macro, the assignment symbol := must occur after the label name and any (par0..par7) parameter list. {$define new_proc := procedure test; begin writeln('ok'); end; } new_proc begin test; end. {$define sum_xi := x:=x+i; } begin sum_xi; end; {$define WIDTH := 80} {$define LEN := ( WIDTH + 10 )} var a: byte; begin a := len * 20; end. Macros with parameters are supported by MP but not by FPC , keep this in mind if you intend to test code on other hardware platforms. {$define SIGN_MASK := $8000} {$define SIGNED_INF_VALUE(x) := ((x and SIGN_MASK) or $7C00)} var a: byte = 11; begin writeln( SIGNED_INF_VALUE(a shl 15) ); end.","title":"Defining a macro"},{"location":"map/","text":"Memory map Atari XE/XL The compiler uses the null side in the range $0080 .. $00D7 When using additional memory, the bank code array for PORTB is placed from $0101 ... $0140 An additional 256 byte memory buffer used for string operations is located from $0400 ... $04FF","title":"Memory map"},{"location":"map/#_1","text":"","title":""},{"location":"map/#memory-map","text":"Atari XE/XL The compiler uses the null side in the range $0080 .. $00D7 When using additional memory, the bank code array for PORTB is placed from $0101 ... $0140 An additional 256 byte memory buffer used for string operations is located from $0400 ... $04FF","title":"Memory map"},{"location":"procedures-functions/","text":"Procedure MP allows up to 8 parameters to be transferred to the procedure. There are three ways to pass parameters - by value, constant CONST and variable VAR . It is possible to use the OVERLOAD modifier to overload procedures. Available procedure modifiers: OVERLOAD ASSEMBLER FORWARD REGISTER INTERRUPT PASCAL . It is possible to recurse procedures, provided that the procedure parameters will be passed by value and will be of a simple - ordinal type. The record or pointer type will not be properly allocated in memory. Function MP allows you to transfer up to 8 parameters to the function. There are three ways to pass parameters - by value, constant CONST and variable VAR . We return the result of the function by assigning it to the function name or using the automatically declared RESULT variable, e.g: function add(a,b: word): cardinal; begin Result := a+b; end; function mul(a,b: word): cardinal; begin mul := a*b; end; Available function modifiers: OVERLOAD ASSEMBLER FORWARD REGISTER INTERRUPT PASCAL , INTERRUPT not recommended for functions. It is possible to recurse functions, provided that the function parameters will be passed by value and will be of a simple - ordinal type. The record or pointer type will not be properly allocated in memory. Modifiers assembler The procedures/functions marked by ASSEMBLER can only consist of an ASM block. The compiler does not analyze the syntax of such blocks, treats them as a comment, possible errors are caught only during the assembly. WARNING It is required to maintain the state of the X CPU6502 register, which is used to operate the MP software stack. procedure color(a: byte); assembler; asm { mva a 712 }; end; overload Overloaded procedures/functions are recognized by the parameter list. procedure sum(var i: integer; a,b: integer); overload; begin i := a+b; end; procedure sum(var i: integer; a,b,c: integer); overload; begin i := a+b+c; end; function fsum(a,b: word): cardinal; assembler; overload; asm { adw a b result }; end; function fsum(a,b: real): real; overload; begin Result := a+b; end; forward If you want the procedure/function to be declared after its first call, use the FORWARD modifier. procedure name [(formal-parameter-list)]; forward; ... ... ... procedure name; begin end; register Using REGISTER modifier causes the first three formal parameters of the procedure/function to be placed on the zero page, in 32-bit general-purpose registers EDX , ECX , EAX respectively. procedure name (a,b,c: cardinal); register; // a = edx // b = ecx // c = eax interrupt Procedures/Functions marked by INTERRUPT end with RTI instruction (instead of standard RTS ). Regardless of whether such procedure/function is called in the program, the compiler always generates code for it. It is recommended to use the ASM block for such procedure/function , otherwise the Mad Pascal software stack will be destroyed, which may lead to unstable program operation, including computer crashes. At the beginning of the procedure/function marked by INTERRUPT , the programmer must take care to keep the CPU registers A X Y , at the output to restore such registers, the compiler only inserts the final RTI command. procedure dli; interrupt; asm { pha lda #$c8 sta wsync sta $d01a pla }; end; // the RTI instruction gets inserted automatically pascal Using the PASCAL modifier will cause procedure/function to be treated as recursive. By default, the compiler automatically detects recursion, but there may be situations where this is not possible. Example samples/math/evaluate.pas stdcall Using the STDCALL modifier will force parameters to be passed to the procedure/function through the program stack. By default, the compiler tries to pass parameters through variables, without involving the program stack. inline The procedure, function is turned into a Mad Assembler macro, getting rid of calls involving the JSR command. It is not possible to use recursion for such procedures/functions .","title":"Procedures, functions, modifiers"},{"location":"procedures-functions/#_1","text":"","title":""},{"location":"procedures-functions/#procedure","text":"MP allows up to 8 parameters to be transferred to the procedure. There are three ways to pass parameters - by value, constant CONST and variable VAR . It is possible to use the OVERLOAD modifier to overload procedures. Available procedure modifiers: OVERLOAD ASSEMBLER FORWARD REGISTER INTERRUPT PASCAL . It is possible to recurse procedures, provided that the procedure parameters will be passed by value and will be of a simple - ordinal type. The record or pointer type will not be properly allocated in memory.","title":"Procedure"},{"location":"procedures-functions/#function","text":"MP allows you to transfer up to 8 parameters to the function. There are three ways to pass parameters - by value, constant CONST and variable VAR . We return the result of the function by assigning it to the function name or using the automatically declared RESULT variable, e.g: function add(a,b: word): cardinal; begin Result := a+b; end; function mul(a,b: word): cardinal; begin mul := a*b; end; Available function modifiers: OVERLOAD ASSEMBLER FORWARD REGISTER INTERRUPT PASCAL , INTERRUPT not recommended for functions. It is possible to recurse functions, provided that the function parameters will be passed by value and will be of a simple - ordinal type. The record or pointer type will not be properly allocated in memory.","title":"Function"},{"location":"procedures-functions/#modifiers","text":"","title":"Modifiers"},{"location":"procedures-functions/#assembler","text":"The procedures/functions marked by ASSEMBLER can only consist of an ASM block. The compiler does not analyze the syntax of such blocks, treats them as a comment, possible errors are caught only during the assembly. WARNING It is required to maintain the state of the X CPU6502 register, which is used to operate the MP software stack. procedure color(a: byte); assembler; asm { mva a 712 }; end;","title":"assembler"},{"location":"procedures-functions/#overload","text":"Overloaded procedures/functions are recognized by the parameter list. procedure sum(var i: integer; a,b: integer); overload; begin i := a+b; end; procedure sum(var i: integer; a,b,c: integer); overload; begin i := a+b+c; end; function fsum(a,b: word): cardinal; assembler; overload; asm { adw a b result }; end; function fsum(a,b: real): real; overload; begin Result := a+b; end;","title":"overload"},{"location":"procedures-functions/#forward","text":"If you want the procedure/function to be declared after its first call, use the FORWARD modifier. procedure name [(formal-parameter-list)]; forward; ... ... ... procedure name; begin end;","title":"forward"},{"location":"procedures-functions/#register","text":"Using REGISTER modifier causes the first three formal parameters of the procedure/function to be placed on the zero page, in 32-bit general-purpose registers EDX , ECX , EAX respectively. procedure name (a,b,c: cardinal); register; // a = edx // b = ecx // c = eax","title":"register"},{"location":"procedures-functions/#interrupt","text":"Procedures/Functions marked by INTERRUPT end with RTI instruction (instead of standard RTS ). Regardless of whether such procedure/function is called in the program, the compiler always generates code for it. It is recommended to use the ASM block for such procedure/function , otherwise the Mad Pascal software stack will be destroyed, which may lead to unstable program operation, including computer crashes. At the beginning of the procedure/function marked by INTERRUPT , the programmer must take care to keep the CPU registers A X Y , at the output to restore such registers, the compiler only inserts the final RTI command. procedure dli; interrupt; asm { pha lda #$c8 sta wsync sta $d01a pla }; end; // the RTI instruction gets inserted automatically","title":"interrupt"},{"location":"procedures-functions/#pascal","text":"Using the PASCAL modifier will cause procedure/function to be treated as recursive. By default, the compiler automatically detects recursion, but there may be situations where this is not possible. Example samples/math/evaluate.pas","title":"pascal"},{"location":"procedures-functions/#stdcall","text":"Using the STDCALL modifier will force parameters to be passed to the procedure/function through the program stack. By default, the compiler tries to pass parameters through variables, without involving the program stack.","title":"stdcall"},{"location":"procedures-functions/#inline","text":"The procedure, function is turned into a Mad Assembler macro, getting rid of calls involving the JSR command. It is not possible to use recursion for such procedures/functions .","title":"inline"},{"location":"projects/","text":"Benchmark Suite author: zbyti platform: A8 sources Star Vagrant author: MADRAFi platform: A8 home page sources Old Mansion author: bocianu platform: A8 home page sources","title":"Projects"},{"location":"projects/#_1","text":"","title":""},{"location":"projects/#benchmark-suite","text":"author: zbyti platform: A8 sources","title":"Benchmark Suite"},{"location":"projects/#star-vagrant","text":"author: MADRAFi platform: A8 home page sources","title":"Star Vagrant"},{"location":"projects/#old-mansion","text":"author: bocianu platform: A8 home page sources","title":"Old Mansion"},{"location":"resources/","text":"Resource files Syntax of RC files The RC files are plain text files. They contain a list of resources to be included in the compiled file. The basic syntax element looks as follows: RCLABEL RCTYPE RCFILE [PAR0, PAR1, PAR2, PAR3, PAR4, PAR5, PAR6, PAR7] The contents of a RC file may include comments, preceded by a ';' or '#' character. An example of a RC file: ; this is a MPT player mpt_player MPTPLAY # this is a MPT modul mpt_modul MPT 'porazka.mpt' The resource type specifies the format of the file to be included. Type Info RCDATA Any type of data. EXTMEM Any data type loaded into PORTB secondary memory, loading address determined by RCLABEL . RCASM The assembler file that will be included and assembled. DOSFILE File with Atari DOS header, the loading address of such a file should be identical to RCLABEL . RELOC Relocatable file in Mad Assembler format, the file will be relocated to the indicated RCLABEL address. RMT The Raster Music Tracker-a module file, the file will be relocated to the indicated RCLABEL address. MPT The Music ProTracker-a module file, the file will be relocated to the indicated RCLABEL address. CMC The Chaos Music Composer-a module file, the file will be relocated to the indicated RCLABEL address. RMTPLAY Player for RMT module, specify *.FEAT file as RCFILE and additionally PAR0 player mode 0..3: 0 => compile RMTplayer for 4 tracks mono 1 => compile RMTplayer for 8 tracks stereo 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4 MPTPLAY Player for MPT module, no need to specify RCFILE file name. CMCPLAY Player for CMC module, no need to specify RCFILE file name. XBMP Windows Bitmap file (8 BitsPerPixel) loaded into VBXE memory at the indicated RCLABEL address from color index PAR0 in VBXE** color palette #1 Including an RC file in the application Insert a compiler directive in the program source code (e.g., at the beginning of the implementation section): {$R myresources.rc} In addition, specify in the program code the value for the RCLABEL labels of the corresponding resources, e.g.: const mpt_player = $8000; mpt_modul = $9000; The inclusion of the RC file occurs when the program is compiled. Access to Resources Resources are placed at the indicated RCLABEL addresses in memory. The only exception is the RCDATA resource type for which it is possible to omit the RCLABEL definition from the program code. In the absence of a RCLABEL definition, the resource is included in the compiled program, accessed via the GetResourceHandle routine. GetResourceHandle(pointer, 'rclabel'); The GetResourceHandle procedure sets the value of the POINTER for the resource 'RCLABEL'.","title":"Resource files"},{"location":"resources/#_1","text":"","title":""},{"location":"resources/#resource-files","text":"","title":"Resource files"},{"location":"resources/#syntax-of-rc-files","text":"The RC files are plain text files. They contain a list of resources to be included in the compiled file. The basic syntax element looks as follows: RCLABEL RCTYPE RCFILE [PAR0, PAR1, PAR2, PAR3, PAR4, PAR5, PAR6, PAR7] The contents of a RC file may include comments, preceded by a ';' or '#' character. An example of a RC file: ; this is a MPT player mpt_player MPTPLAY # this is a MPT modul mpt_modul MPT 'porazka.mpt' The resource type specifies the format of the file to be included. Type Info RCDATA Any type of data. EXTMEM Any data type loaded into PORTB secondary memory, loading address determined by RCLABEL . RCASM The assembler file that will be included and assembled. DOSFILE File with Atari DOS header, the loading address of such a file should be identical to RCLABEL . RELOC Relocatable file in Mad Assembler format, the file will be relocated to the indicated RCLABEL address. RMT The Raster Music Tracker-a module file, the file will be relocated to the indicated RCLABEL address. MPT The Music ProTracker-a module file, the file will be relocated to the indicated RCLABEL address. CMC The Chaos Music Composer-a module file, the file will be relocated to the indicated RCLABEL address. RMTPLAY Player for RMT module, specify *.FEAT file as RCFILE and additionally PAR0 player mode 0..3: 0 => compile RMTplayer for 4 tracks mono 1 => compile RMTplayer for 8 tracks stereo 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4 MPTPLAY Player for MPT module, no need to specify RCFILE file name. CMCPLAY Player for CMC module, no need to specify RCFILE file name. XBMP Windows Bitmap file (8 BitsPerPixel) loaded into VBXE memory at the indicated RCLABEL address from color index PAR0 in VBXE** color palette #1","title":"Syntax of RC files"},{"location":"resources/#including-an-rc-file-in-the-application","text":"Insert a compiler directive in the program source code (e.g., at the beginning of the implementation section): {$R myresources.rc} In addition, specify in the program code the value for the RCLABEL labels of the corresponding resources, e.g.: const mpt_player = $8000; mpt_modul = $9000; The inclusion of the RC file occurs when the program is compiled.","title":"Including an RC file in the application"},{"location":"resources/#access-to-resources","text":"Resources are placed at the indicated RCLABEL addresses in memory. The only exception is the RCDATA resource type for which it is possible to omit the RCLABEL definition from the program code. In the absence of a RCLABEL definition, the resource is included in the compiled program, accessed via the GetResourceHandle routine. GetResourceHandle(pointer, 'rclabel'); The GetResourceHandle procedure sets the value of the POINTER for the resource 'RCLABEL'.","title":"Access to Resources"},{"location":"syntax/","text":"Comments In MP // is used to mark a one-line comment and { } or (* *) mark a multiline comment. // this is a comment inc(a); // this also is a comment (* comment *) (* comment *) { this is a comment } Reserved identifiers reserved commands absolute and array asm assembler begin case const div do downto else end exports external file for forward function if implementation in interrupt interface library main mod not object of or overload pascal procedure program record register repeat shl shr string text textfile then to type unit until uses var while xor reserved constants pi true false nil eol nan infinity neginfinity Expressions Numbers decimal notation -100 -2437325 1743 hexadecimal notation $100 $e430 $000001 binary notation %0001001010 %000000001 %001000 ATASCII code notation 'a' 'fds' 'W' #65#32#65 #$9b Operators arithmetic + Addition - Subtraction * Multiplication / Division DIV Integer division MOD Remainder bitwise NOT Bitwise negation (unary) AND Bitwise and OR Bitwise or XOR Bitwise xor SHL Bitwise shift to the left SHR Bitwise shift to the right logical NOT logical negation (unary) AND logical and OR logical or XOR logical xor relational = Equal <> Not equal < Less than > Greater than <= Less than or equal >= Greater than or equal Compiler directives Compiler directives are of form:: {$directive parameters} {$list_of_switch_directives} A directive is a comment differentiated from a regular comment by the first $ character. CONDITIONAL {$IFDEF label} {$IFNDEF label} {$ELSE} {$ENDIF} {$DEFINE label} {$UNDEF label} {$define test} const {$ifdef test} a=1; {$else} a=2; {$endif} From the assembly level access to defined $DEFINE directives is only possible through MAIN.@DEFINES.label . $F, $FASTMUL {$fastmul page} // fastmul at page*256 {$f $70} // fastmul at $7000 Alternative procedures for fast multiplication of the BYTE SHORTINT WORD SMALLINT SHORTREAL types. The procedures occupy 2KB and are located starting from the address PAGE*256 . $I+, $I-, IOCHECK {$I+} {$I-} {i+} IOCHECK ON default {i-} IOCHECK OFF For {$i+} in case of I/O transmission errors RESET REWRITE BLOCKREAD BLOCKWRITE CLOSE the ran program is stopped and an error diagnostic ERROR xxx is generated. Disabling IOCHECK {$i-} is of use for file existence checking, for example: function FileExists(name: TString): Boolean; var f: file; begin {$I-} // io check off Assign (f, name); Reset (f); Result:=(IoResult<128) and (length(name)>0); Close (f); {$I+} // io check on end; In PROCEDURE and FUNCTION blocks, the IOCHECK directive is of local scope, after finishing the compilation of such block the previous value of IOCHECK , defined outside of such block, is restored. $I, $INCLUDE %DATE% {$INCLUDE %DATE%} {$I %DATE%} Directive parameter %DATE% for inclusion of a string with current compilation date. %TIME% {$INCLUDE %TIME%} {$I %TIME%} Directive parameter %TIME% for inclusion of a string with current compilation time. FILENAME {$INCLUDE filename} {$I filename} Directive parameter FILENAME to attach the text contained in the file. $LIBRARYPATH {$LIBRARYPATH path1;path2;...} Directive to indicate additional search paths for libraries unit . $INFO {$INFO user_defined} Generate info message. $WARNING {$WARNING user_defined} Generate warning message. $ERROR {$ERROR user_defined} Generate error message. $DEFINE BASICOFF {$DEFINE BASICOFF} Additional code block that shutdown ATARI BASIC . ROMOFF {$DEFINE ROMOFF} We gain access to the memory under the ROM : $C000..$CFFF , $D800..$FFFF . The character set from ROM $E000..$E3FF is rewritten to the same address in RAM , the interrupt handler NMI , IRQ is installed. The operating system works normally, you can call the procedures contained in it from the ASM using the macro m@call . $R, $RESOURCE {$R filename} {$RESOURCE filename} RCLABEL RCTYPE RCFILE [PAR0 PAR1 PAR2 PAR3 PAR4 PAR5 PAR6 PAR7] Directive to attach a resource file. A resource file is a text file, each of its successive lines should consist of three fields separated by a white character : RCLABEL , the label (its declaration must also be included in the program), RCTYPE , the resource type and RCFILE , the file location. Currently, the BASE\\RES6502.ASM file contains macros to support 10 types of RCTYPE resources: RCDATA Any data type. EXTMEM Any data type loaded into PORTB secondary memory, loading address determined by RCLABEL . RCASM An assembly file that will be attached and assembled. DOSFILE Atari DOS header file, the loading address of such a file should be the same as RCLABEL . RELOC A relocatable file in MadAssembler format, the file will be relocated to the address indicated by RCLABEL . RMT Raster Music Tracker module file, the file will be relocated to the address indicated by RCLABEL . MPT The Music ProTracker module file, the file will be relocated to the indicated address RCLABEL . CMC Chaos Music Composer module file, the file will be relocated to the address indicated by RCLABEL . RMTPLAY Player for the RMT module, with the *.FEAT file passed as the RCFILE and the player mode 0..3 passed as the PAR0 . 0 => compile RMTplayer for 4 tracks mono 1 => compile RMTplayer for 8 tracks stereo 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4 MPTPLAY Player for MPT module. CMCPLAY Player for CMC module. XBMP Windows Bitmap file (8 BitsPerPixel) loaded into VBXE memory to the indicated address RCLABEL from PAR0 color index in VBXE color palette no. 1. Example: bmp1 RCDATA 'pic.mic' msx MPT 'porazka.mpt' play RMTPLAY 'modul.feat' 1 bmp XBMP 'pic.bmp' 80","title":"Syntax"},{"location":"syntax/#_1","text":"","title":""},{"location":"syntax/#comments","text":"In MP // is used to mark a one-line comment and { } or (* *) mark a multiline comment. // this is a comment inc(a); // this also is a comment (* comment *) (* comment *) { this is a comment }","title":"Comments"},{"location":"syntax/#reserved-identifiers","text":"","title":"Reserved identifiers"},{"location":"syntax/#reserved-commands","text":"absolute and array asm assembler begin case const div do downto else end exports external file for forward function if implementation in interrupt interface library main mod not object of or overload pascal procedure program record register repeat shl shr string text textfile then to type unit until uses var while xor","title":"reserved commands"},{"location":"syntax/#reserved-constants","text":"pi true false nil eol nan infinity neginfinity","title":"reserved constants"},{"location":"syntax/#expressions","text":"","title":"Expressions"},{"location":"syntax/#numbers","text":"","title":"Numbers"},{"location":"syntax/#decimal-notation","text":"-100 -2437325 1743","title":"decimal notation"},{"location":"syntax/#hexadecimal-notation","text":"$100 $e430 $000001","title":"hexadecimal notation"},{"location":"syntax/#binary-notation","text":"%0001001010 %000000001 %001000","title":"binary notation"},{"location":"syntax/#atascii-code-notation","text":"'a' 'fds' 'W' #65#32#65 #$9b","title":"ATASCII code notation"},{"location":"syntax/#operators","text":"","title":"Operators"},{"location":"syntax/#arithmetic","text":"+ Addition - Subtraction * Multiplication / Division DIV Integer division MOD Remainder","title":"arithmetic"},{"location":"syntax/#bitwise","text":"NOT Bitwise negation (unary) AND Bitwise and OR Bitwise or XOR Bitwise xor SHL Bitwise shift to the left SHR Bitwise shift to the right","title":"bitwise"},{"location":"syntax/#logical","text":"NOT logical negation (unary) AND logical and OR logical or XOR logical xor","title":"logical"},{"location":"syntax/#relational","text":"= Equal <> Not equal < Less than > Greater than <= Less than or equal >= Greater than or equal","title":"relational"},{"location":"syntax/#compiler-directives","text":"Compiler directives are of form:: {$directive parameters} {$list_of_switch_directives} A directive is a comment differentiated from a regular comment by the first $ character.","title":"Compiler directives"},{"location":"syntax/#conditional","text":"{$IFDEF label} {$IFNDEF label} {$ELSE} {$ENDIF} {$DEFINE label} {$UNDEF label} {$define test} const {$ifdef test} a=1; {$else} a=2; {$endif} From the assembly level access to defined $DEFINE directives is only possible through MAIN.@DEFINES.label .","title":"CONDITIONAL"},{"location":"syntax/#f-fastmul","text":"{$fastmul page} // fastmul at page*256 {$f $70} // fastmul at $7000 Alternative procedures for fast multiplication of the BYTE SHORTINT WORD SMALLINT SHORTREAL types. The procedures occupy 2KB and are located starting from the address PAGE*256 .","title":"$F, $FASTMUL"},{"location":"syntax/#i-i-iocheck","text":"{$I+} {$I-} {i+} IOCHECK ON default {i-} IOCHECK OFF For {$i+} in case of I/O transmission errors RESET REWRITE BLOCKREAD BLOCKWRITE CLOSE the ran program is stopped and an error diagnostic ERROR xxx is generated. Disabling IOCHECK {$i-} is of use for file existence checking, for example: function FileExists(name: TString): Boolean; var f: file; begin {$I-} // io check off Assign (f, name); Reset (f); Result:=(IoResult<128) and (length(name)>0); Close (f); {$I+} // io check on end; In PROCEDURE and FUNCTION blocks, the IOCHECK directive is of local scope, after finishing the compilation of such block the previous value of IOCHECK , defined outside of such block, is restored.","title":"$I+, $I-, IOCHECK"},{"location":"syntax/#i-include","text":"","title":"$I, $INCLUDE"},{"location":"syntax/#date","text":"{$INCLUDE %DATE%} {$I %DATE%} Directive parameter %DATE% for inclusion of a string with current compilation date.","title":"%DATE%"},{"location":"syntax/#time","text":"{$INCLUDE %TIME%} {$I %TIME%} Directive parameter %TIME% for inclusion of a string with current compilation time.","title":"%TIME%"},{"location":"syntax/#filename","text":"{$INCLUDE filename} {$I filename} Directive parameter FILENAME to attach the text contained in the file.","title":"FILENAME"},{"location":"syntax/#librarypath","text":"{$LIBRARYPATH path1;path2;...} Directive to indicate additional search paths for libraries unit .","title":"$LIBRARYPATH"},{"location":"syntax/#info","text":"{$INFO user_defined} Generate info message.","title":"$INFO"},{"location":"syntax/#warning","text":"{$WARNING user_defined} Generate warning message.","title":"$WARNING"},{"location":"syntax/#error","text":"{$ERROR user_defined} Generate error message.","title":"$ERROR"},{"location":"syntax/#define","text":"","title":"$DEFINE"},{"location":"syntax/#basicoff","text":"{$DEFINE BASICOFF} Additional code block that shutdown ATARI BASIC .","title":"BASICOFF"},{"location":"syntax/#romoff","text":"{$DEFINE ROMOFF} We gain access to the memory under the ROM : $C000..$CFFF , $D800..$FFFF . The character set from ROM $E000..$E3FF is rewritten to the same address in RAM , the interrupt handler NMI , IRQ is installed. The operating system works normally, you can call the procedures contained in it from the ASM using the macro m@call .","title":"ROMOFF"},{"location":"syntax/#r-resource","text":"{$R filename} {$RESOURCE filename} RCLABEL RCTYPE RCFILE [PAR0 PAR1 PAR2 PAR3 PAR4 PAR5 PAR6 PAR7] Directive to attach a resource file. A resource file is a text file, each of its successive lines should consist of three fields separated by a white character : RCLABEL , the label (its declaration must also be included in the program), RCTYPE , the resource type and RCFILE , the file location. Currently, the BASE\\RES6502.ASM file contains macros to support 10 types of RCTYPE resources:","title":"$R, $RESOURCE"},{"location":"syntax/#rcdata","text":"Any data type.","title":"RCDATA"},{"location":"syntax/#extmem","text":"Any data type loaded into PORTB secondary memory, loading address determined by RCLABEL .","title":"EXTMEM"},{"location":"syntax/#rcasm","text":"An assembly file that will be attached and assembled.","title":"RCASM"},{"location":"syntax/#dosfile","text":"Atari DOS header file, the loading address of such a file should be the same as RCLABEL .","title":"DOSFILE"},{"location":"syntax/#reloc","text":"A relocatable file in MadAssembler format, the file will be relocated to the address indicated by RCLABEL .","title":"RELOC"},{"location":"syntax/#rmt","text":"Raster Music Tracker module file, the file will be relocated to the address indicated by RCLABEL .","title":"RMT"},{"location":"syntax/#mpt","text":"The Music ProTracker module file, the file will be relocated to the indicated address RCLABEL .","title":"MPT"},{"location":"syntax/#cmc","text":"Chaos Music Composer module file, the file will be relocated to the address indicated by RCLABEL .","title":"CMC"},{"location":"syntax/#rmtplay","text":"Player for the RMT module, with the *.FEAT file passed as the RCFILE and the player mode 0..3 passed as the PAR0 . 0 => compile RMTplayer for 4 tracks mono 1 => compile RMTplayer for 8 tracks stereo 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4","title":"RMTPLAY"},{"location":"syntax/#mptplay","text":"Player for MPT module.","title":"MPTPLAY"},{"location":"syntax/#cmcplay","text":"Player for CMC module.","title":"CMCPLAY"},{"location":"syntax/#xbmp","text":"Windows Bitmap file (8 BitsPerPixel) loaded into VBXE memory to the indicated address RCLABEL from PAR0 color index in VBXE color palette no. 1. Example: bmp1 RCDATA 'pic.mic' msx MPT 'porazka.mpt' play RMTPLAY 'modul.feat' 1 bmp XBMP 'pic.bmp' 80","title":"XBMP"},{"location":"types/","text":"Ordinal types Type Range Size in bytes BYTE 0 .. 255 1 SHORTINT -128 .. 127 1 WORD 0 .. 65535 2 SMALLINT -32768 .. 32767 2 CARDINAL 0 .. 4294967295 4 LONGWORD 0 .. 4294967295 4 DWORD 0 .. 4294967295 4 UINT32 0 .. 4294967295 4 INTEGER -2147483648 .. 2147483647 4 LONGINT -2147483648 .. 2147483647 4 Boolean types Type Ord(True) Size in bytes BYTE 1 1 Enumeration types The enumeration type in MP has been implemented in its basic form, i.e.: Type Days = (monday,tuesday,wednesday,thursday,friday, saturday,sunday); Joy = (right_down = 5, right_up, right, left_down = 9, left_up, left, down = 13, up, none); The enumeration type is stored only in the memory of the MP compiler, no information about the enumeration type fields will be stored in the result file. It is permissible to use the ORD , SIZEOF and casts on the enumeration type. var d: Days; d:=friday; writeln(ord(d)); writeln(ord(sunday)); writeln(sizeof(days)); writeln(sizeof(monday)); d:=days(20); case d of sunday: writeln('sunday'); end; Currently, the MP compiler does not check the correctness of enumeration types for IF ELSE operations. Real types Type Range Size in bytes SHORTREAL (Q8.8) -128..127 2 REAL (Q24.8) -8388607..8388608 4 SINGLE (IEEE-754) 1.5E-45 .. 3.4E38 4 FLOAT (IEEE-754) 1.5E-45 .. 3.4E38 4 Conversion of FLOAT SINGLE to INTEGER type is only available in the range INTEGER . The INTEGER type will not allow to present the maximum value 3.4E38 of FLOAT SINGLE type. Char types Type Range Size in bytes CHAR ATASCII (0 .. 255) 1 STRING 1 .. 255 256 PCHAR 0 .. 65535 2 The STRING is represented as an array with a possible maximum size [0..255] . The first byte of such an array [0] is the string length from the range 0..255 . The actual character string begins from the byte [1..] . A pointer to the CHAR type represents the PCHAR string. The terminator of the PCHAR string is the #0 character. It is allowed to use additional characters after the final apostrophe, such as * , ~ . The character * means a string in the inverse; the tilde ~ means a string in ANTIC codes. Another way to modify the output characters is to use the system variable TextAttr , each character output to the screen is increased by the value TextAttr (default = 0). a: string = 'Atari'*; // a character string in the inverse b: string = 'Spectrum'~; // a character string in ANTIC codes c: char = 'X'~*; // a character in inverted ANTIC codes Pointers Type Range Size in bytes POINTER 0 .. 65535 2 Indicators in MP can be typed and without a specific type, e.g.: a: ^word; // a typed pointer to a word b: pointer; // an untyped pointer An uninitialized pointer will most often have the address of $0000 , you should make sure that before you use it, you will have initialized it with the address of the appropriate variable, e.g.: a := @tmp; // pointer A is assigned the address of the TMP variable If you don't do this, if you run such a program on a PC , you may cause a memory protection fault Access Violation . Increasing the pointer using INC increases it by the size of the type it indicates. Decreasing the pointer using DEC reduces it by the size of the type it indicates. If the type is unspecified, the default step for increase/decrease is 1 . Static arrays Tables in MP are only static, one-dimensional or two-dimensional with an initial index equal to 0 , e.g: var tb: array [0..100] of word; var tb2: array [0..15, 0..31] of Boolean; For an initial index other than zero, an error Error Array lower bound is not zero is generated. In the memory the array is represented by the pointer POINTER , the pointer is the address of the array in memory (WORD). The quickest way to refer to the table from the assembler level is to use the prefix ADR , e.g.: asm { lda adr.tb,y ; direct reference to the TB array lda tb ; reference to the TB array pointer }; The compiler generates code for the arrays depending on their declaration: when the number of bytes does not exceed 256 bytes array [0..255] of byte array [0..127] of word array [0..63] of cardinal When the number of bytes occupied by the array does not exceed 256 bytes, the fastest code referring directly to the address of the array (prefix ADR. ) is generated without the pointer. It is not possible to change the address for such an array. ldy #118 lda adr.tb,y when the number of elements of an array is 1 array [0..0] of type When the number of elements of an array is 1 it is treated specifically. The code generated refers to the array through the pointer. It is possible to set a new address for such a table. lda TB add I tay lda TB+1 adc #$00 sta bp+1 lda (bp),y when the number of bytes exceeds 256 bytes array [0..255+1] of byte array [0..127+1] of word array [0..63+1] of cardinal When the number of bytes occupied by the array exceeds 256 bytes, the generated code refers to the array via an pointer. When the number of bytes occupied by the array exceeds 256 bytes, the generated code refers to the array through a pointer. lda TB add I tay lda TB+1 adc #$00 sta bp+1 lda (bp),y Record types In the memory the record is represented by a pointer POINTER . type TPoint = record x,y: byte end; var px: TPoint; By default, records in MP are of type PACKED . If you want to maintain FPC compatibility, you should additionally precede the word record with the word packed . Without this, the size of the memory that the record takes varies, it occupies less memory on Atari XE/XL , potentially several bytes more on the PC . type TPoint = packed record x,y: byte end; var px: TPoint; Access to record fields from the assembly: mwa px bp2 ldy #px.x-DATAORIGIN lda (bp2),y Object types Objects are records with additional methods. In the memory, the object is represented by a pointer POINTER . type TRMT = Object player: pointer; modul: pointer; procedure Init(a: byte); assembler; procedure Play; assembler; procedure Stop; assembler; end; It is possible to use the CONSTRUCTOR and DESTRUCTOR procedures in objects. Such procedures can only be called manually. File types The FILE type represents the file handle and defines the record size. type ftype = array [0..63] of cardinal; var f: file; // default record =128 bytes f: file of byte; // 1 byte record f: file of ftype; // 256 byte record (ftype = 64 * 4) In the XE/XL memory, the FILE holder is represented by a pointer POINTER to an array of structure (size 12 bytes): .struct s@file pfname .word ; pointer to string with filename record .word ; record size chanel .byte ; channel *$10 eof .byte ; EOF status buffer .word ; load/write buffer nrecord .word ; number of records for load/write numread .word ; pointer to variable, length of loaded data .ends For procedures and functions, the FILE type can only be passed as a variable VAR .","title":"Types"},{"location":"types/#_1","text":"","title":""},{"location":"types/#ordinal-types","text":"Type Range Size in bytes BYTE 0 .. 255 1 SHORTINT -128 .. 127 1 WORD 0 .. 65535 2 SMALLINT -32768 .. 32767 2 CARDINAL 0 .. 4294967295 4 LONGWORD 0 .. 4294967295 4 DWORD 0 .. 4294967295 4 UINT32 0 .. 4294967295 4 INTEGER -2147483648 .. 2147483647 4 LONGINT -2147483648 .. 2147483647 4","title":"Ordinal types"},{"location":"types/#boolean-types","text":"Type Ord(True) Size in bytes BYTE 1 1","title":"Boolean types"},{"location":"types/#enumeration-types","text":"The enumeration type in MP has been implemented in its basic form, i.e.: Type Days = (monday,tuesday,wednesday,thursday,friday, saturday,sunday); Joy = (right_down = 5, right_up, right, left_down = 9, left_up, left, down = 13, up, none); The enumeration type is stored only in the memory of the MP compiler, no information about the enumeration type fields will be stored in the result file. It is permissible to use the ORD , SIZEOF and casts on the enumeration type. var d: Days; d:=friday; writeln(ord(d)); writeln(ord(sunday)); writeln(sizeof(days)); writeln(sizeof(monday)); d:=days(20); case d of sunday: writeln('sunday'); end; Currently, the MP compiler does not check the correctness of enumeration types for IF ELSE operations.","title":"Enumeration types"},{"location":"types/#real-types","text":"Type Range Size in bytes SHORTREAL (Q8.8) -128..127 2 REAL (Q24.8) -8388607..8388608 4 SINGLE (IEEE-754) 1.5E-45 .. 3.4E38 4 FLOAT (IEEE-754) 1.5E-45 .. 3.4E38 4 Conversion of FLOAT SINGLE to INTEGER type is only available in the range INTEGER . The INTEGER type will not allow to present the maximum value 3.4E38 of FLOAT SINGLE type.","title":"Real types"},{"location":"types/#char-types","text":"Type Range Size in bytes CHAR ATASCII (0 .. 255) 1 STRING 1 .. 255 256 PCHAR 0 .. 65535 2 The STRING is represented as an array with a possible maximum size [0..255] . The first byte of such an array [0] is the string length from the range 0..255 . The actual character string begins from the byte [1..] . A pointer to the CHAR type represents the PCHAR string. The terminator of the PCHAR string is the #0 character. It is allowed to use additional characters after the final apostrophe, such as * , ~ . The character * means a string in the inverse; the tilde ~ means a string in ANTIC codes. Another way to modify the output characters is to use the system variable TextAttr , each character output to the screen is increased by the value TextAttr (default = 0). a: string = 'Atari'*; // a character string in the inverse b: string = 'Spectrum'~; // a character string in ANTIC codes c: char = 'X'~*; // a character in inverted ANTIC codes","title":"Char types"},{"location":"types/#pointers","text":"Type Range Size in bytes POINTER 0 .. 65535 2 Indicators in MP can be typed and without a specific type, e.g.: a: ^word; // a typed pointer to a word b: pointer; // an untyped pointer An uninitialized pointer will most often have the address of $0000 , you should make sure that before you use it, you will have initialized it with the address of the appropriate variable, e.g.: a := @tmp; // pointer A is assigned the address of the TMP variable If you don't do this, if you run such a program on a PC , you may cause a memory protection fault Access Violation . Increasing the pointer using INC increases it by the size of the type it indicates. Decreasing the pointer using DEC reduces it by the size of the type it indicates. If the type is unspecified, the default step for increase/decrease is 1 .","title":"Pointers"},{"location":"types/#static-arrays","text":"Tables in MP are only static, one-dimensional or two-dimensional with an initial index equal to 0 , e.g: var tb: array [0..100] of word; var tb2: array [0..15, 0..31] of Boolean; For an initial index other than zero, an error Error Array lower bound is not zero is generated. In the memory the array is represented by the pointer POINTER , the pointer is the address of the array in memory (WORD). The quickest way to refer to the table from the assembler level is to use the prefix ADR , e.g.: asm { lda adr.tb,y ; direct reference to the TB array lda tb ; reference to the TB array pointer }; The compiler generates code for the arrays depending on their declaration: when the number of bytes does not exceed 256 bytes array [0..255] of byte array [0..127] of word array [0..63] of cardinal When the number of bytes occupied by the array does not exceed 256 bytes, the fastest code referring directly to the address of the array (prefix ADR. ) is generated without the pointer. It is not possible to change the address for such an array. ldy #118 lda adr.tb,y when the number of elements of an array is 1 array [0..0] of type When the number of elements of an array is 1 it is treated specifically. The code generated refers to the array through the pointer. It is possible to set a new address for such a table. lda TB add I tay lda TB+1 adc #$00 sta bp+1 lda (bp),y when the number of bytes exceeds 256 bytes array [0..255+1] of byte array [0..127+1] of word array [0..63+1] of cardinal When the number of bytes occupied by the array exceeds 256 bytes, the generated code refers to the array via an pointer. When the number of bytes occupied by the array exceeds 256 bytes, the generated code refers to the array through a pointer. lda TB add I tay lda TB+1 adc #$00 sta bp+1 lda (bp),y","title":"Static arrays"},{"location":"types/#record-types","text":"In the memory the record is represented by a pointer POINTER . type TPoint = record x,y: byte end; var px: TPoint; By default, records in MP are of type PACKED . If you want to maintain FPC compatibility, you should additionally precede the word record with the word packed . Without this, the size of the memory that the record takes varies, it occupies less memory on Atari XE/XL , potentially several bytes more on the PC . type TPoint = packed record x,y: byte end; var px: TPoint; Access to record fields from the assembly: mwa px bp2 ldy #px.x-DATAORIGIN lda (bp2),y","title":"Record types"},{"location":"types/#object-types","text":"Objects are records with additional methods. In the memory, the object is represented by a pointer POINTER . type TRMT = Object player: pointer; modul: pointer; procedure Init(a: byte); assembler; procedure Play; assembler; procedure Stop; assembler; end; It is possible to use the CONSTRUCTOR and DESTRUCTOR procedures in objects. Such procedures can only be called manually.","title":"Object types"},{"location":"types/#file-types","text":"The FILE type represents the file handle and defines the record size. type ftype = array [0..63] of cardinal; var f: file; // default record =128 bytes f: file of byte; // 1 byte record f: file of ftype; // 256 byte record (ftype = 64 * 4) In the XE/XL memory, the FILE holder is represented by a pointer POINTER to an array of structure (size 12 bytes): .struct s@file pfname .word ; pointer to string with filename record .word ; record size chanel .byte ; channel *$10 eof .byte ; EOF status buffer .word ; load/write buffer nrecord .word ; number of records for load/write numread .word ; pointer to variable, length of loaded data .ends For procedures and functions, the FILE type can only be passed as a variable VAR .","title":"File types"},{"location":"units/","text":"UNIT The modules UNIT in MP consist of sections INTERFAC required , IMPLEMENTATION required , INITIALIZATION optional . unit test; interface type TUInt24 = record byte0: byte; byte1: byte; byte2: byte; end; const LoRes = 1; MedRes = 2; HiRes = 3; procedure Print(a: string); implementation uses test2; procedure Print(a: string); begin writeln(a); end; end.","title":"Units"},{"location":"units/#_1","text":"","title":""},{"location":"units/#unit","text":"The modules UNIT in MP consist of sections INTERFAC required , IMPLEMENTATION required , INITIALIZATION optional . unit test; interface type TUInt24 = record byte0: byte; byte1: byte; byte2: byte; end; const LoRes = 1; MedRes = 2; HiRes = 3; procedure Print(a: string); implementation uses test2; procedure Print(a: string); begin writeln(a); end; end.","title":"UNIT"},{"location":"usage/","text":"Compiler switches Syntax: mp source [switches] -diag diagnostic mode -define:symbol defines a symbol -ipath:<x> dadditional search path -target:<x> terget system: a8 (default), c64 -code:address program launch address -data:address memory address of variables and arrays -stack:address address of stack (64 bytes) -zpage:address address of variables in the zero page (26 bytes) The use of the -diag switch causes the generation of an additional file with information about all used variables, procedures, and functions. The default extension of output file is *.A65 , assembled using the Mad-Assembler , additionally the search path is set using -i:base , for example: mads source.a65 -x -i:base The -x switch Exclude unreferenced procedures allows for the generation of shortest output code for the 6502 . Exit codes 3 = bad parameters, compiling not started 2 = error occured 0 = no errors Warning diagnostics do not affect the exit code.","title":"Usage"},{"location":"usage/#_1","text":"","title":""},{"location":"usage/#compiler-switches","text":"Syntax: mp source [switches] -diag diagnostic mode -define:symbol defines a symbol -ipath:<x> dadditional search path -target:<x> terget system: a8 (default), c64 -code:address program launch address -data:address memory address of variables and arrays -stack:address address of stack (64 bytes) -zpage:address address of variables in the zero page (26 bytes) The use of the -diag switch causes the generation of an additional file with information about all used variables, procedures, and functions. The default extension of output file is *.A65 , assembled using the Mad-Assembler , additionally the search path is set using -i:base , for example: mads source.a65 -x -i:base The -x switch Exclude unreferenced procedures allows for the generation of shortest output code for the 6502 .","title":"Compiler switches"},{"location":"usage/#exit-codes","text":"3 = bad parameters, compiling not started 2 = error occured 0 = no errors Warning diagnostics do not affect the exit code.","title":"Exit codes"}]}